## Види автоматизованого тестування

Покриття тестами, які перевіряють невеликі функції, що викликаються в додатку, має наближатися до 100%, коли ж тестування сценаріїв користувача може покривати лише невеликий відсоток функціональності програми, наприклад, це можуть бути лише smoke-тести

### Unit/Component/Module Tests (юніт/компонентне/модульне тестування)

Сама низькорівнева категорія тестів. Головне завдання юніт-тестів полягає у перевірці логіки в окремих ділянках коду (функціях, методах, модулях тощо). Також юніт-тести включать в себе компонентні тести (тестування на рівні компонентів чи класів). Наприклад, тестування компонента форми реєстрації.

#### Ізоляція даних в юніт-тестуванні

Ізоляція — один із головних принципів написання тестів. Для того, щоб унеможливити реальний виклик функцій з інших частин системи в тестах використовують mock та stub. Наприклад, якщо тестований метод сортування масиву в собі викликає метод отримання даних з компонента-сховища, то згаданий компонент та її метод можна «замокати» на повернення даних, які потрібні в цьому конкретному тесті. Таким чином, буде протестована тільки частина коду, яка сортує дані. Адже компонент-сховище може викликати в себе звернення до бази даних, що не потрібно перевіряти при юніт-тестуванні. У наведеному прикладі метод повернення даних є mock, а ось «не справжні» дані, що повертаються ним є stub

### Acceptance Tests (API layer) (приймальне тестування)

У цих тестах ми зосереджуємося лише на нашому коді та створеній системі. Ми мокаємо всі зовнішні залежності. Якщо ми не можемо замокати їх, ми намагаємося створити локальні, в пам’яті або реалізації, якими ми можемо керувати

### Integration (інтеграційні тестування)

Перевіряють код, який інтегрується з іншими системами. Прикладом інтеграційного тестування можуть бути тести перевірки правильної роботи компонента форми реєстрації та модуля-сховища даних із зверненням до бази даних

### System tests (системне тестування)

Дозволяють перевірити цілісність архітектури системи та її поведінки у певних ситуаціях, а не тестування взаємодії окремих частин програми. Прикладом системного тестування може бути перевірка продуктивності програми за великої кількості одночасних відвідувачів, або іншими словами, тестування навантаження

### UI/GUI/End-to-end/smoke tests

#### UI tests

Код працює правильно, якщо користувач бачить інтерфейс, який був задуманий автором. Інтерфейс вирішує завдання, для яких він створювався

-   Компоненти мають використовуватися так, як задумано
-   Картинка, що бачить користувач має бути повною
-   Взаємодії з інтерфейсом мають бути передбачуваними

#### Smoke Tests (димові тести)

Набір чек-листів, які визначають базову працездатність програми або сайту. Наприклад, для інтернет-магазину набором димових-тестів можуть бути такі групи сценаріїв

-   Можливість зайти до каталогу товарів
-   Можливість переглянути сторінку з товаром
-   Можливість зробити замовлення
-   Можливість прочитати інформацію про доставку та оплату
-   Можливість дізнатися фізичну адресу магазину

А ось сценарії з логіном користувача для надання особистої знижки або можливість зміни адреси електронної пошти в профілі в наведеному абстрактному прикладі не здаються обов'язковими цілями сайту, і тому можуть не потрапити до списку смоук-тестів

#### End-to-end (наскрізні тести)

Тестування системи в цілому, емулюючи реальне середовище користувача. Це тести, запущені в браузері, що імітують клацання мишею та натискання клавіш. Наскрізне воно називається, тому що перевіряють бізнес функції системи. Якщо брати термінологію тестування, то e2e — це тестування поведінки за методом «чорної скриньки». Приклад сценарію для наскрізного тесту може бути таким

1.  Фреймворк коректно рендерить компонент вітального екрану
    1.  в DOM є всі потрібні елементи
1.  Користувач натискає на кнопку «Почати гру»
    1.  Симуляція події на клік по DOM-елементом кнопки
    1.  Перевірка, що обробник, доданий на кнопку був викликаний та відпрацював
1.  Фреймворк рендерить перший ігровий екран
1.  В DOM є все потрібні елементи

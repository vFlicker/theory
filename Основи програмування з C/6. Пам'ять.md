# Пам'ять

У внутрішній структурі наших комп'ютерів містяться чіпи оперативної пам'яті, відомої як RAM (Random Access Memory), яка призначена для зберігання даних для короткострокового використання. Можливо зберігати файли на жорсткому диску або SSD для довгострокового зберігання, але кожен раз, коли ми відкриваємо файл для редагування, вміст цього файлу копіюється в оперативну пам'ять. Хоча обсяг оперативної пам'яті (RAM) набагато менший, ніж потужність жорсткого диска чи SSD. Попри те, що обсяг RAM значно менший та вона є тимчасовою (поки не буде вимкнене живлення), вона значно швидша.

## Байти і комірки пам'яті

Дані, які зберігаються в оперативній пам'яті, можна уявити як сітку, де кожна комірка відповідає одному байту. Насправді, це мільйони або навіть мільярди байтів на кожному чіпі оперативної пам'яті. Коли ми працюємо з даними в програмі, ми насправді працюємо зі значеннями, які зберігаються в цих комірках пам'яті.

У мові програмування С коли ми створюємо змінну типу `char` розміром в один байт, вона буде фізично збережена в одній із таких комірок у RAM. Ціле число на чотири байти займе чотири таких комірки.

## Масиви

У пам'яті дані можна зберігати послідовно, один за одним. В мові програмування C, список збережених змінних, які розташовані в суміжних комірках пам'яті, називається масивом. Масиви дозволяють нам збирати дані в циклі та отримувати доступ до них, також у циклі. Наприклад, ми можемо визначити масив `scores` для зберігання оцінок і використовувати цей масив, щоб зберегти результати від користувача.

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    int scores[3]; // Оголошення масиву для зберігання 3 оцінок

    for (int i = 0; i < 3; i++)
    {
        scores[i] = get_int("Оцінка %i: ", i + 1); // Зберегти оцінку в масив
    }

    // Далі можна використовувати масив scores для обробки даних
}
```

Важливо зазначити, що індекси масиву рахуються з нуля, тобто перший елемент масиву має індекс 0, другий - 1 і так далі. Масиви дозволяють зберігати дані у впорядкованому форматі та доступатися до них за допомогою індексів.

## Рядки

Рядки - це послідовності символів, які зберігаються у пам'яті комп'ютера. Кожен символ у рядку представлений відповідним числовим значенням (ASCII-кодом). Рядок можна розглядати як масив символів, і доступ до кожного символу можна отримати за допомогою індексу. Кожен символ у рядку відповідає одному байту пам'яті, і має власну адресу у пам'яті. Рядки завершуються нуль-символом `'\0'`, який позначає кінець рядка. Цей нуль-символ дозволяє визначати довжину рядка і виконувати операції з рядками.

### Операції над рядками

У мові програмування С рядки підтримуються за допомогою бібліотеки `string.h`. Основні операції над рядками включають:

#### Отримання довжини рядка

```c
#include <string.h>
int len = strlen(s);
```

#### Зміна регістру символів

```c
#include <ctype.h>
char upper = toupper(c); // Перетворення на великі літери
char lower = tolower(c); // Перетворення на малі літери
```

#### Доступ до окремих символів рядка

```c
char c = s[i]; // Отримати символ за індексом i
```

#### Ітерація по рядку

```c
for (int i = 0; i < strlen(s); i++)
{
    printf("%c\n", s[i]);
}
```

#### Порівняння рядків

У мові C для порівняння двох рядків за їхнім вмістом використовується функція `strcmp`. Проте важливо знати, що `strcmp` фактично порівнює адреси рядків, тобто адреси їхніх перших символів. Це означає, що функція порівнює рядки за їхніми адресами у пам'яті, незалежно від їхнього вмісту.

```c
if (strcmp(s1, s2) == 0) {
    // Рядки s1 та s2 мають однаковий вміст
} else {
    // Рядки s1 та s2 мають різний вміст
}
```

### Аргументи командного рядка

Під час виконання програми користувач може передавати аргументи через командний рядок. Ми можемо отримати доступ до цих аргументів у функції main за допомогою двох параметрів:

- `argc` — кількість аргументів (включаючи назву програми).
- `argv` — масив рядків, які представляють аргументи.

Приклад використання аргументів командного рядка:

```c
int main(int argc, string argv[])
{
    if (argc == 2)
    {
        printf("Hello, %s\n", argv[1]);
    }
    else
    {
        printf("Hello, world\n");
    }
}
```

У цьому прикладі ми перевіряємо наявність другого аргументу (ім'я користувача) і виводимо відповідне повідомлення.


### Копіювання рядків

Для копіювання рядків важливо виділити пам'ять для нового рядка та скопіювати кожен символ окремо. Просте присвоєння адреси може призвести до небажаних результатів. Використовуйте функції виділення та звільнення пам'яті, такі як `malloc` і `free`, для ефективної роботи з рядками.

```c
char *copy = malloc((strlen(original) + 1) * sizeof(char)); // Виділення пам'яті
strcpy(copy, original); // Копіювання рядка

// Використовуйте copy

free(copy); // Звільнення виділеної пам'яті
```

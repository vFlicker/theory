## Введення у Node.js

Node.js — програма, яка дозволяє запускати javascript-сценарії в оточенні операційної системи, а не в оточенні браузера

### Середа виконання Node.js

-   Віртуальна машина V8
    -   Читає та перевіряє JavaScript код
    -   Виконує JavaScript код
-   Модулі доступу до файлової системи
    -   Читання/запис/видалення файлів
    -   Робота з мережею та мережевими пристроями
    -   Надання доступу до операційної системи

### Ключові особливості

-   Асинхронність замість паралельності
-   Горизонтальне масштабування проти вертикального
-   Вбудований пакетний менеджер (NPM)
-   Легкість (1 процес, 1.5GB RAM)
-   Немає браузерного API (BOM)
-   Усі скрипти за замовчуванням є CommonJS модулями
-   Виконати можна рівно один файл — цей файл називається точкою входу (зазвичай index.js)
-   Відмінність роботи програми на Node.js полягає в тому, що якщо всі операції закінчено, то робота Node.js припиниться
-   REPL (Read-Eval-Print Loop) — інтерактивне середовище
    розробки, що дозволяє вводити команди та
    конструкції мови і відразу їх виконувати

### Базові можливості

-   Усі конструкції мови ECMA2015+
-   Всі глобальні вбудовані об'єкти:
    -   Рядки, числа, примітиви, базові об'єкти
    -   Вбудовані бібліотеки: Math, Intl, Reflect
    -   Promise
    -   JSON

### Додаткові можливості

-   Робота з файловою системою
-   Робота з мережею: socket, HTTP/HTTP2, UDP
-   Робота з потоками: stream

### Глобальні змінні

-   Об'єкт для роботи з консоллю — console
-   Глобальна область видимості — global
-   Інформація про поточний модуль — module
-   Інформація про поточний процес — process
-   Допоміжні об'єкти: require, **dirname, **filename, exports
-   Інше — Buffer

## Modules

NPM (Node Package Manager) — програма, яка дозволяє керувати залежностями вашого проекту

### Навіщо потрібний пакетний менеджер

-   Перевикористання коду
-   Автоматизація стандартних операцій у проекті
-   Зручність відстеження змін та оновлень
-   Поділ коду на модулі

### Модуль

-   Ізолює простір імен
-   Описує залежності
-   Описує те, що він надає назовні

### Завантажувач модулів

-   Шукає модуль
-   Завантажує модуль на вимогу
-   Кешує вже завантажені модулі

### Особливості require

-   Коли Node.js зустрічає вбудовану функцію require він інтерпретує рядок, яку в неї передали як шлях до модуля, який потрібно завантажити
-   Модуль завантажується рівно один раз. Після того як Node.js одного разу завантажив модуль — він його кешує (зберігає результат виконання модуля), тобто. ніякий модуль не буде завантажений та виконаний двічі, неважливо скільки разів він був підключений
-   Node.js завжди використовує UNIX-style шляхи (через /)
-   Шляхи в реєстрозалежних та реєстрозалежних файлових системах поводяться по різному. Більше того в реєстронезалежних системах по-різному завантажені модулі можуть призводити до повторного завантаження модуля
-   Розширення файлу можна опустити
-   Якщо послатися на папку з модулем index.js, то Node.js підключить завантажити цей модуль із папки
-   Вираз require.main === module — поверне true тільки в тому випадку, якщо цей модуль був вхідним файлом (точкою входу)

### Алгоритм завантаження модулів

1. Якщо шлях збігається з ім'ям вбудованого модуля
    1. Завантажити модуль
1. Якщо шлях починається з '/'
    1. Завантажити модуль по абсолютному шляху
1. Якщо шлях починається з './' або '../'
    1. Спробувати завантажити як файл щодо поточного модуля
    1. Спробувати завантажити як папку
1. Спробувати завантажити як залежність
1. Викинути помилку, що такий модуль не знайдено

### Область видимості модуля

-   module — об'єкт, що описує поточний модуль
-   exports — посилання на об'єкт module.exports
-   require — функція, яка підключає модулі
-   \_\_filename — абсолютний шлях до модуля
-   \_\_dirname — абсолютний шлях до директорії в якій лежить модуль

### Module wrapper (модульна обгортка)

```js
function load(info) {
    const module = {
        exports: {},
        require: (path) => {
            /* ... */
        },
    };

    ((exports, require, module, __filename, __dirname) => {
        module.exports = {
            // Файл mother.js
            name: `Мама`,
            age: 12,
            male: false,
        };

        exports.name = `Оксана`;
    })(module.exports, module.require, module);

    return module.exports;
}
```

### Обмеження модулів

-   Ніколи не кладіть об'єкт у змінну exports, краще використовувати module.exports
-   Ніколи не експортуйте значення асинхронно чи всередині умов, тому що вони можуть виявитися непроініціалізовані
-   Розширення файлу у залежності можна опустити
-   Уникайте циклів

## Event loop (цикл подій)

```
   ┌────────────────────────┐
┌─>│        таймери         │
│  └──────────┬─────────────┘
│  ┌──────────┴─────────────┐
│  │       I/O колбеки      │
│  └──────────┬─────────────┘
│  ┌──────────┴─────────────┐
│  │ очікування, підготовка │
│  └──────────┬─────────────┘      ┌───────────────┐
│  ┌──────────┴─────────────┐      │  вхідні:      │
│  │       опитування       │<─────┤  з'єднання,   │
│  └──────────┬─────────────┘      │  дані, и т.д. │
│  ┌──────────┴─────────────┐      └───────────────┘
│  │       перевірка        │
│  └──────────┬─────────────┘
│  ┌──────────┴─────────────┐
└──┤     колбеки `close`    │
   └────────────────────────┘
```

### Фази циклу подій

-   Таймери: у цій фазі виконуються коллбеки, заплановані setTimeout()та setInterval();
-   I/O коллбеки: виконуються майже всі коллбеки, за винятком подій close, таймерів та setImmediate();
-   Очікування, підготовка: використовується лише для внутрішніх цілей;
-   Опитування: отримання нових подій введення/виведення. Node.js може блокуватись на цьому етапі;
-   Перевірка: коллбеки, викликані setImmediate(), викликаються цьому етапі;
-   Коллбеки події close: наприклад, socket.on('close', ...);

### Async/await

Конструкції мови, що дозволяють привести асинхронний код для синхронного вигляду. **Важливо**, що це лише представлення коду, сам код залишається асинхронним за своєю природою

Async

-   Ключове слово для функції чи методу
-   Функція, позначена як async, завжди повертає Promise
-   Async функцію ніколи не має сенсу викликати всередині _try...catch_ блоку

Await

-   Ключове слово, доступне всередині async-функції
-   Дозволяє дочекатися результату роботи Promise
-   Якщо в результаті await роботи Promise викинув виняток, то його можна обробити за допомогою блоку _try...catch_

Особливості

-   Будь-яка функція, яка повертає Promise працює так само, як async-функція
-   Під час виклику async-функції завжди потрібно стежити за тим, щоб оброблявся результат Promise
-   Await ніколи не замикається - не може бути вкладений в іншу функцію (так само як return)
-   Конструктори не можуть бути асинхронними
-   Гетери та сетери не можуть бути асинхронними

```js
/*
    Якщо використовувати await біля функцій resolveAfter2Seconds,
    виконання методу sum займе ~4 секунди
*/
const sum = async (x) => {
    const a = resolveAfter2Seconds(1);
    const b = resolveAfter2Seconds(2);
    return x + (await a) + (await b);
};
```

```js
/*
    Якщо не перевіряти initialized, є ймовірність,
    що відбудеться створення нового інстансу
*/
class Singleton {
    constructor() {
        this.order = order++;
        console.log("I'm the first one");
    }

    static async init() {
        await resolveAfter2Seconds(); // simulate async loading
        return new Singleton();
    }
}

let instance;

const getInstance = async () => {
    if (instance) return instance;

    const initialized = await Singleton.init();
    if (!initialized) instance = initialized;

    return instance;
};

getInstance().then((i) => console.log(i.order));
getInstance().then((i) => console.log(i.order));
getInstance().then((i) => console.log(i.order));
```

```js
/* Виконання такого коду займе ~20 секунд */
const iterate = async (num) => {
    let sum = 0;
    for (let i = 0; i < 10>; i++) {
        sum += await resolveAfter2Seconds(10);
    }
    return sum;
};
```

## Stream (потік)

-   Дозволяє читати дані по частинам
-   Stream є EventEmitter з фіксованою кількістю подій
-   Буває чотирьох видів:
    -   Write (в який можна тільки писати)
    -   Read (з якого можна лише читати)
    -   Duplex (до якого можна і читати та писати)
    -   Transform (який трансформує дані на льоту)

### Read Stream

-   Stream, з якого можна читати дані
-   Основні події
    -   data — частина даних завантажена та готова для читання
    -   end — дані закінчилися
    -   error — під час читання даних сталася помилка
-   Основні методи
    -   pipe(description, options) — дозволяє перенаправити вивід у Write Stream

### Write Stream

-   Stream, в який можна писати дані
-   Основні події
    -   drain — повідомляє, що передані дані були успішно записані та можна продовжити писати дані
    -   error — під час читання даних сталася помилка
-   Основні методи:
    -   write(chunk, encoding, callback) — дозволяє записати частину даних
    -   end(chunk, encoding, callback) — повертає останню частину даних та повідомляє про
        тому, що дані закінчилися

## HTTP

HTTP 1.1 — протокол передачі даних, описує у якому вигляді обмінюються інформацією клієнт та сервер

### HTTP 1.1 Запит

```
GET /index.php HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

### HTTP 1.1 Відповідь

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1270
Cache-Control: max-age=604800
Date: Tue, 24 Oct 2017 11:08:24 GMT
Etag: "359670651+ident"
Expires: Tue, 31 Oct 2017 11:08:24 GMT
Last-Modified: Fri, 09 Aug 2013 23:54:35 GMT
Server: ECS (dca/53DB)
Vary: Accept-Encoding
X-Cache: HIT
<!doctype html>
<html>
<head>
<title>Example Domain</title>
```

### HTTP методи

-   GET — запит на отримання інформації із сервера
-   HEAD — запит для перевірки, чи оновилася інформація на сервері і чи варто заново її завантажити або можна залишити закешовану версію
-   OPTIONS — запит для перевірки, які запити можна робити на цей ресурс

-   POST — запит на створення нового запису на сервері
-   PUT — запит на перезапис наявної інформації на сервері
-   DELETE — запит на видалення наявної інформації на сервері
-   PATCH — запит на частковий перезапис наявної інформації на сервері

### Коди стану HTTP

-   1xx — інформаційні повідомлення
-   2xx — успішні повідомлення
-   3xx — перенаправлення
-   4xx — помилка у запиті клієнта
-   5xx — помилки сервера

### Media Type (MIME Type/Content Type)

Media Type — спеціальний формат для вказівки типу даних. Спочатку з'явився для вказівки типу вкладених файлів в електронних листах (Multipurpose
Internet Mail Extensions)

### Media types (типи даних)

-   top-level type name (назва класу даних) / subtype name (назва типу даних)
-   application / json
-   image / jpeg
-   text / html
-   application / x-www-form-urlencoded
-   multipart / form-data
-   application / octet-stream

### Запуск серверу

```js
const http = require("http");

const hostname = "127.0.0.1";
const port = 3000;

const server = http.createServer((req, res) => {
    res.statusCode = 200;
    res.setHeader("Content-Type", "text/plain");
    res.end("Hello World\n");
});

server.listen(port, hostname, () => {
    console.log(`Server running at http://${hostname}:${port}`);
});
```

**Примітки**

-   За замовчуванням порт для роботи з http – це порт 80, тобто. якщо в адресі не вказано порт, то браузер за замовчуванням буде використовувати порт 80 для HTTP і порт 443 для HTTPS
-   На деяких операційних системах порти (\*nix) <1024 заборонені для використання з правами звичайного користувача

### Request (об'єкт запиту)

-   Реалізує всі методи та події Read Stream
-   request.headers — заголовки запиту (пари ключ-значення)
-   request.httpVersion — версія протоколу HTTP, яку запросив клієнт
-   request.method — метод, яким звернувся клієнт
-   request.url — локальна адреса, яку запитав клієнт
-   для роботи з URL є модуль url, який дозволяє розпарсити URL з рядка в об'єкт і назад

### Response (об'єкт відповіді)

-   Реалізує всі методи та події Write Stream
-   response.statusCode – поле, що зберігає код відповіді (наприклад: 200, 404, 501)
-   response.statusMessage — поле, що зберігає повідомлення відповідь (наприклад: 'OK', 'Not Found')
-   response.writeHead() — метод, який надсилає заголовок
-   response.write() — метод, який надсилає частину тіла відповіді
-   response.end(data, encoding, callback) — метод, який повідомляє, що відповідь записана

## Introduction to Node.js

Node.js — програма, яка дозволяє запускати javascript-сценарії в оточенні операційної системи, а не в оточенні браузера

### Середа виконання Node.js

-   Віртуальна машина V8
    -   Читає та перевіряє JavaScript код
    -   Виконує JavaScript код
-   Модулі доступу до файлової системи
    -   Читання/запис/видалення файлів
    -   Робота з мережею та мережевими пристроями
    -   Надання доступу до операційної системи

### Ключові особливості

-   Асинхронність замість паралельності
-   Горизонтальне масштабування проти вертикального
-   Вбудований пакетний менеджер (NPM)
-   Легкість (1 процес, 1.5GB RAM)
-   Немає браузерного API (BOM)
-   Усі скрипти за замовчуванням є CommonJS модулями
-   Виконати можна рівно один файл — цей файл називається точкою входу (зазвичай index.js)
-   Відмінність роботи програми на Node.js полягає в тому, що якщо всі операції закінчено, то робота Node.js припиниться
-   REPL (Read-Eval-Print Loop) — інтерактивне середовище
    розробки, що дозволяє вводити команди та
    конструкції мови і відразу їх виконувати

### Базові можливості

-   Усі конструкції мови ECMA2015+
-   Всі глобальні вбудовані об'єкти:
    -   Рядки, числа, примітиви, базові об'єкти
    -   Вбудовані бібліотеки: Math, Intl, Reflect
    -   Promise
    -   JSON

### Додаткові можливості

-   Робота з файловою системою
-   Робота з мережею: socket, HTTP/HTTP2, UDP
-   Робота з потоками: stream

### Глобальні змінні

-   Об'єкт для роботи з консоллю — console
-   Глобальна область видимості — global
-   Інформація про поточний модуль — module
-   Інформація про поточний процес — process
-   Допоміжні об'єкти: require, **dirname, **filename, exports
-   Інше — Buffer

## Modules

NPM (Node Package Manager) — програма, яка дозволяє керувати залежностями вашого проекту

### Навіщо потрібний пакетний менеджер

-   Перевикористання коду
-   Автоматизація стандартних операцій у проекті
-   Зручність відстеження змін та оновлень
-   Поділ коду на модулі

### Модуль

-   Ізолює простір імен
-   Описує залежності
-   Описує те, що він надає назовні

### Завантажувач модулів

-   Шукає модуль
-   Завантажує модуль на вимогу
-   Кешує вже завантажені модулі

### Особливості require

-   Коли Node.js зустрічає вбудовану функцію require він інтерпретує рядок, яку в неї передали як шлях до модуля, який потрібно завантажити
-   Модуль завантажується рівно один раз. Після того як Node.js одного разу завантажив модуль — він його кешує (зберігає результат виконання модуля), тобто. ніякий модуль не буде завантажений та виконаний двічі, неважливо скільки разів він був підключений
-   Node.js завжди використовує UNIX-style шляхи (через /)
-   Шляхи в реєстрозалежних та реєстрозалежних файлових системах поводяться по різному. Більше того в реєстронезалежних системах по-різному завантажені модулі можуть призводити до повторного завантаження модуля
-   Розширення файлу можна опустити
-   Якщо послатися на папку з модулем index.js, то Node.js підключить завантажити цей модуль із папки
-   Вираз require.main === module — поверне true тільки в тому випадку, якщо цей модуль був вхідним файлом (точкою входу)

### Алгоритм завантаження модулів

1. Якщо шлях збігається з ім'ям вбудованого модуля
    1. Завантажити модуль
1. Якщо шлях починається з '/'
    1. Завантажити модуль по абсолютному шляху
1. Якщо шлях починається з './' або '../'
    1. Спробувати завантажити як файл щодо поточного модуля
    1. Спробувати завантажити як папку
1. Спробувати завантажити як залежність
1. Викинути помилку, що такий модуль не знайдено

### Область видимості модуля

-   module — об'єкт, що описує поточний модуль
-   exports — посилання на об'єкт module.exports
-   require — функція, яка підключає модулі
-   \_\_filename — абсолютний шлях до модуля
-   \_\_dirname — абсолютний шлях до директорії в якій лежить модуль

### Module wrapper (модульна обгортка)

```js
function load(info) {
    const module = {
        exports: {},
        require: (path) => {
            /* ... */
        },
    };

    ((exports, require, module, __filename, __dirname) => {
        module.exports = {
            // Файл mother.js
            name: `Мама`,
            age: 12,
            male: false,
        };

        exports.name = `Оксана`;
    })(module.exports, module.require, module);

    return module.exports;
}
```

### Обмеження модулів

-   Ніколи не кладіть об'єкт у змінну exports, краще використовувати module.exports
-   Ніколи не експортуйте значення асинхронно чи всередині умов, тому що вони можуть виявитися непроініціалізовані
-   Розширення файлу у залежності можна опустити
-   Уникайте циклів

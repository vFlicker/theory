## SOLID

### S

SRP (Single Responsibility Principle / Принцип єдиної відповідальності) — кожен об'єкт, клас та метод повинні відповідати лише за щось одне. Якщо об'єкт/клас/метод робить занадто багато, ви отримаєте спагетті-код. Ще один побічний ефект такого коду — проблеми із тестуванням. Заплутаний функціонал тестувати складно

```js
/**
 * Цей метод робить занадто багато
 */
const saveTodo = async () => {
    try {
        // Зберігає об'єкт
        await saveTodoApi();

        // Обробляє повідомлення у UI
        showSuccessPop("Success");

        // Виконує навігацію
        window.location.href = "/successPage";
    } catch (error) {
        // Обробляє повідомлення у UI
        showErrorPopup(`Error: ${error} `);
    }
};
```

### O

OCP (Open-Closed Principle / Принцип відкритості-закритості) — програмні сутності повинні бути відкриті до розширення, але закриті для модифікації. Йдеться про те, що не можна перевизначати методи чи класи, просто додаючи додаткові функції за необхідності. Просте правило: якщо ви змінюєте сутність, щоб зробити її розширюваною, ви вперше порушили цей принцип

### L

LSP (Liskov substitution principle / Принцип підстановки Лісків) — цей принцип свідчить, що об'єкти старших класів повинні бути замінені об'єктами підкласів, і додаток за такої заміни повинен працювати так, як очікується

### I

ISP (Interface Segregation Principle / Принцип поділу інтерфейсів) — об'єкти не повинні залежати від інтерфейсів, які вони не використовують. Закликає не створювати жирні універсальні інтерфейси. Натомість інтерфейси потрібно розділяти на більш дрібні та спеціалізовані, це допоможе гнучкіше їх комбінувати в імплементуючих класах, не змушуючи імплементувати зайві методи. Переконайтеся, що ви не змушуєте об'єкти реалізовувати методи, які їм ніколи не знадобляться

```ts
/** Не всі тварини можуть fly, walk або swim, тому
 * ці методи не повинні бути частиною інтерфейсу
 * або повинні бути необов'язковими.
 */
interface Animal {
    eat: () => void;
    walk: () => void;
    fly: () => void;
    swim: () => void;
}
```

### D

DIP (Dependency Inversion / Принцип інверсії залежностей) — залежність на абстракціях. Немає залежності на щось конкретне. Простий приклад — використання дат JavaScript. Ви можете написати їм свій шар абстракції. Тоді якщо у вас зміниться джерело отримання дат, вам потрібно буде внести зміни в одному місці, а не тисячі

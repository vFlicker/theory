## The Clean Architecture

Ключова ідея даної діаграми полягає в тому, що програма ділитися на шари (шарів може бути будь-яка кількість). Внутрішні шари не знають про зовнішні, залежності направлені до центру. Чим далі шар від центру, тим більше він знає про «небізесові» деталі програми (наприклад, що за фреймворк використовується і скільки кнопок на екрані)

### Архітектура повинна бути

-   Тестованою
-   Не залежати від UI
-   Не залежати від БД, зовнішніх фреймворків та бібліотек

### Шари

#### Entities (сутності)

У центрі у нас є Entities. У них укладено бізнес-логіку програми і тут немає залежностей від платформи. Entities описують лише бізнес-логіку програми. Наприклад, візьмемо клас Cart (кошик) — ми можемо додати товар у кошик, видалити його тощо. Нічого про такі речі, як React, бази даних, кнопки - цей клас не знає. Ми зможемо взяти цілісну сутність з Web-додатку на React і вставити код для NodeJS без змін

Entities містить

Entities — функції або об'єкти з методами, які реалізують логіку бізнесу, загальну для багатьох програм (а якщо бізнесу немає, то найвищу логіку програми)
DTO — необхідні для роботи та переходу між шарами

#### Use cases (Interactors) (сценарії використання)

Interactor — об'єкт, який реалізує use case (сценарій використання), використовуючи бізнес-об'єкти (Entities).

Use case — це деталізація, опис дії, яку може зробити користувач системи

У другому шарі діаграми розташовані Use Cases. Сценарії використання описують, як взаємодіяти з сутностями у контексті нашого додатку. Наприклад, якщо сутність знає тільки про те, що до неї можна додати замовлення — сценарій використання знає, що з сутності можна взяти це замовлення і відправити до репозиторію

#### Interface Adapters (інтерфейсні адаптери)

До цього шару належать Gateways (шлюзи), Presenters (доповідачі), Controllers (контролери). У цьому контексті (Gateways = Repositories, Presenters = View Models) — шари системи, які відповідають за зв'язок між бізнес-правилами програми та платформно залежними частинами системи. Наприклад, репозиторії надають інтерфейси, які будуть реалізовувати класи для доступу до API або сховищ, а View Model інтерфейс буде служити для зв'язку React-компонентів із викликами бізнес-логіки

#### External interfaces (зовнішні інтерфейси)

Платформенно залежний шар. Тут є прямі звернення до API, компоненти React і т.д.. Саме цей шар найважче піддається тестуванню та абстрагуванню

### Boundaries (ports)

Порти — специфікації того, як наш додаток хоче, щоб з ним спілкувався зовнішній світ.

Зазвичай порт — це інтерфейс, контракт на поведінку.

Перехід між шарами здійснюється через два інтерфейси: один для запиту і один для відповіді. Їх можна побачити праворуч на оригінальній схемі (Input/OutputPort). Вони потрібні, щоб внутрішній шар не залежав від зовнішнього (дотримуючись Dependency Rule), але при цьому міг передати йому дані

### Література

<a href="https://habr.com/ru/company/mobileup/blog/335382/">Омани Clean Architecture</a>

<a href="https://habr.com/ru/post/499078/">Clean Architecture на TypeScript та React</a>

<a href="https://bespoyasov.ru/blog/clean-architecture-on-frontend/">Чиста архітектура у фронтенті</a>

<a href="https://habr.com/ru/post/499078/">Clean Architecture на TypeScript та React</a>

<a href="https://feature-sliced.design/">Feature-Sliced Design</a>

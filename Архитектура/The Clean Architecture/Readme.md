# The Clean Architecture

## Dependency Rule (правило залежності)

Говорить нам, що програма ділитися на шари (шарів може бути будь-яка кількість). Внутрішні шари не повинні залежати від зовнішні, залежності направлені до центру. Чим далі шар від центру, тим більше він знає про «не бізнесові» деталі програми (наприклад, що за фреймворк використовується і скільки кнопок на екрані)

## Архітектура повинна

-   Бути тестованою
-   Не залежати від UI
-   Не залежати від БД, зовнішніх фреймворків та бібліотек

## Шари

-   Entities (сутності) — бізнес-логіка загальна для багатьох програм
-   Use cases (сценарії використання) — логіка програми
-   Interface Adapters (інтерфейсні адаптери) — адаптери між Use Cases та зовнішнім світом. Сюди потрапляють Presenter'и з MVP, а також Gateways (популярніша назва репозиторії)
-   Frameworks — самий зовнішній шар тут лежить все інше: UI, база даних, http-клієнт і т.п.

## Boundaries (переходи)

Щоб залежність була направлена ​​у бік зворотного потоку даних, застосовується принцип інверсії залежностей (літера D з абревіатури SOLID). Тобто замість того, щоб UseCase безпосередньо залежав від Presenter'a (що порушувало б Dependency Rule), він залежить від інтерфейсу у своєму шарі, а Presenter має цей інтерфейс реалізувати

## Потік даних (рис. 05)

Подія користувача йде в Presenter, який передає в Use Case. Use Case робить запит у Repository. Repository отримує дані десь, створює Entity, передає його до UseCase. Так Use Case отримує всі необхідні йому Entity. Потім, застосувавши їх та свою логіку, отримує результат, який передає назад у Presenter. А той, своєю чергою, відображає результат в UI

На переходах між шарами (відзначеними різним кольором) використовуються Boundaries, описані раніше

## Шари, а не сутності

Хтось думає, що на схемах зображені сутності (особливо це стосується UseCases і Entities). Але це не так.

На схемах зображені шари, у яких може бути багато сутностей. В них будуть знаходитися інтерфейси для переходів між шарами (Boundaries), різні DTO, основні класи шару (Interactors для шару UseCases, наприклад).

У шарі UseCases (рис. 06) знаходяться не тільки Interactor'и, а й Boundaries для роботи з презентером, інтерфейс для роботи з репозиторієм, DTO для запиту та відповіді.

## Entities

Entities містять бізнес-правила, незалежні від програми. І вони не просто об'єкти із даними. Entities можуть містити посилання на об'єкти з даними, але основне їхнє призначення в тому, щоб реалізувати методи бізнес-логіки, які можуть використовуватись у різних застосуноках. Наприклад, візьмемо клас Cart (кошик) — ми можемо додати товар у кошик, видалити його тощо. Нічого про такі речі, як React, бази даних — цей клас не знає. Ми зможемо взяти цілісну сутність з web-застосуноку на React і вставити код для NodeJS без змін. Отже шар Entities містить:

-   Entities — функції або об'єкти з методами, які реалізують логіку бізнесу, загальну для багатьох програм (а якщо бізнесу немає, то бізнес-об'єктам програми, що містять найзагальніші та високорівневі правила)
-   DTO, необхідні для роботи та переходу між шарами

## Use cases (сценарії використання) / Interactors

У другому шарі діаграми розташовані Use Cases. Сценарії використання описують, як взаємодіяти з сутностями у контексті нашого застосуноку. Наприклад, якщо сутність знає тільки про те, що до неї можна додати замовлення — сценарій використання знає, що з сутності можна взяти це замовлення і відправити до репозиторію.

Interactor/UseCase — об'єкт, що реалізує use case (сценарій використання). Use case — це деталізація, опис дії, яку може зробити користувач системи

## Interface Adapters (інтерфейсні адаптери)

До цього шару належать Gateways (шлюзи), Presenters (доповідачі), Controllers (контролери). У цьому контексті (Gateways = Repositories, Presenters = View Models) — шари системи, які відповідають за зв'язок між бізнес-правилами програми та платформно залежними частинами системи. Наприклад, репозиторії надають інтерфейси, які будуть реалізовувати класи для доступу до API або сховищ, а View Model інтерфейс буде служити для зв'язку React-компонентів із викликами бізнес-логіки

### Repository/Gateway

Є різновидом фасаду, де ми ховаємо складне API за простими методами. В ідеалі використовувати Repository потрібно лише через Interactor. Але у невеликих проектах, де ймовірність додавання логіки до Interactor мізерно мала, можна цим правилом поступитися. В якості компромісу з собою

### Мапінг даних

В Interactor дані повинні потрапляти вже в потрібному вигляді. Мапінг відбувається у шарі Interface Adapters, тобто в Presenter та Repository

## External interfaces (зовнішні інтерфейси)

Платформенно залежний шар. Тут є прямі звернення до API, компоненти React і т.д. Саме цей шар найважче піддається тестуванню та абстрагуванню

## Література

<a href="https://habr.com/ru/company/mobileup/blog/335382/">Омани Clean Architecture</a>

<a href="https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/">DDD, Hexagonal, Onion, Clean, CQRS, … How I put it all together</a>

<a href="https://bespoyasov.ru/blog/clean-architecture-on-frontend/">Чиста архітектура у фронтенті</a>

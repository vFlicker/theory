# ООП (Об'єктно-орієнтоване програмування)

Об'єктно-орієнтоване програмування — це парадигма програмування, яка акцентує на створенні модульного, багаторазового та легко підтримуваного коду за допомогою організації його в об'єкти. Об'єкти є екземплярами класів, які визначають властивості та поведінку цих об'єктів.

## Ключові поняття ООП

### Інкапсуляція

Інкапсуляція відноситься до практики групування даних та методів, які діють на ці дані в рамках одного об'єкта. Вона також гарантує контроль доступу до полів та методів об'єкта. Для цього існують модифікатори доступу:

- `public` (публічний) — до атрибуту може отримати доступ будь-хто.
- `private` (приватний) — до атрибуту можуть звертатися лише методи цього класу.
- `protected` (захищений) — те ж, що і `private`, тільки доступ отримують і спадкоємці класу, включаючи їх.

```ts
class Car {
  private make: string;
  private model: string;

  constructor(make: string, model: string) {
    this.make = make;
    this.model = model;
  }

  getMake(): string {
    return this.make;
  }

  getModel(): string {
    return this.model;
  }
}

const car = new Car("Toyota", "Camry");
console.log(car.getMake());  // Виводить "Toyota"
console.log(car.getModel());  // Виводить "Camry"
```

### Наслідування

Наслідування дозволяє створювати класи на основі вже існуючих, успадковуючи їх властивості та методи. При розробці ієрархії класів важливо:

- Не створювати занадто довгі ланцюжки прототипів.
- Робити батьківські класи максимально абстрактними.
- Уникати проблеми множинного наслідування.

Альтернативи наслідуванню включають:

- Композицію.
- Делегування.
- Mixins.
- Інтерфейси.

Щоб визначити, коли використовувати наслідування або композицію, запитайте себе, чи сутність А є сутністю Б (наслідування) чи частиною сутності Б (композиція).

```ts
class Animal {
  constructor(private name: string) {}

  speak(): void {
    // Базовий метод, що буде перевизначено в підкласах
  }
}

class Dog extends Animal {
  speak(): string {
    return "Woof!";
  }
}

class Cat extends Animal {
  speak(): string {
    return "Meow!";
  }
}

const dog = new Dog("Buddy");
console.log(dog.speak());  // Виводить "Woof!"

const cat = new Cat("Whiskers");
console.log(cat.speak());  // Виводить "Meow!"
```

### Поліморфізм

Поліморфізм дозволяє мати безліч реалізацій одного інтерфейсу, що забезпечує більшу гнучкість і модульність коду.

```ts
class Guitarist {
  play(): string {
    // Базовий метод, що буде перевизначено в підкласах
    return "";
  }
}

class ElectricGuitarist extends Guitarist {
  play(): string {
    return "Playing electric guitar";
  }
}

class AcousticGuitarist extends Guitarist {
  play(): string {
    return "Playing acoustic guitar";
  }
}

function perform(guitarist: Guitarist): string {
  return guitarist.play();
}

const electricGuitarist = new ElectricGuitarist();
const acousticGuitarist = new AcousticGuitarist();

console.log(perform(electricGuitarist));  // Виводить "Playing electric guitar"
console.log(perform(acousticGuitarist));  // Виводить "Playing acoustic guitar"
```

Користь поліморфізму в даному прикладі полягає в тому, що код гри нічого не знає про реалізацію його прохання, хто як повинен грати. Замість цього, його завдання просто викликати метод play, сигнатура якого однакова для всіх класів гітаристів. Це дозволяє додавати нові класи гітаристів або змінювати методи існуючих, не змінюючи код гри.

#### Переваги поліморфізму

- Гнучкість — Зміна або додавання нових класів гітаристів не вимагає змін в коді гри.
- Модульність — Кожен клас гітариста може бути розроблений та підтримуваний окремо.
- Спрощення коду — Код гри залишається спрощеним і не залежить від конкретних реалізацій гітаристів.

# Менеджер контексту

Менеджер контексту (context manager) — це універсальний механізм в Python для автоматичного керування ресурсами. Вони використовуються для виконання певного коду в рамках контексту, а потім звільнення ресурсів, які використовувалися в цьому контексті.

## Переваги використання менеджерів контексту

-   Зручність: Вам не потрібно вручну відкривати та закривати ресурси.
-   Читабельність: Завдяки конструкції `with` код стає більш читабельним та зрозумілим.
-   Безпека: Менеджери контексту гарантують, що ресурси будуть звільнені, навіть якщо виникає виняток.

## Приклади використання

### Без менеджера контексту

```py
opened_file = open('some_file.txt', 'w')

try:
    opened_file.write('Hello!')
finally:
    opened_file.close()
```

### З менеджером контексту

```py
with open('some_file.txt', 'w') as opened_file:
    opened_file.write('Hello!')
```

## Створення менеджеру контексту

Менеджер контексту визначається через реалізацію двох методів: `__enter__` та `__exit__`.

-   `__enter__`: Метод, що відповідає за початкову налаштування контексту та повернення значення, яке буде пов'язане з `as` у конструкції `with`. Може відкрити файл, встановити з'єднання з базою даних або зарезервувати ресурси.
-   `__exit__`: Метод, який викликається після завершення виконання блоку коду в межах контексту. Він використовується для звільнення ресурсів та обробки винятків. Може закрити файл, від'єднатися від бази даних або звільнити зарезервовані ресурси.

```py
import os


class change_directory:
    def __init__(self, path):
        self.path = path

    def __enter__(self):
        # Логіка для відкриття ресурсу

        self.old_path = os.getcwd()
        os.chdir(self.path)

    def __exit__(self, exc_type, exc_value, traceback):
        # Логіка для закриття ресурсу
        # exc_type, exc_value, traceback — використовуються для обробки винятків, якщо вони виникають

        os.chdir(self.old_path)
        return False
```

## Створення менеджеру контексту за допомогою `@contextmanager`

1. `@contextmanager` декорує функцію `change_directory`, перетворюючи її на менеджер контексту.
2. Функція `change_directory` приймає шлях до каталогу як аргумент.
3. Внутрішній код функції використовує `try...finally` для гарантованого повернення до початкового каталогу, незалежно від того, чи виникне виняток чи ні.
4. `yield` використовується для позначення точки, де виконання коду в блоці `with` буде тимчасово призупинено, а потім відновлено після завершення блоку.

```py
import os
from contextlib import contextmanager


@contextmanager
def change_directory(path):
    old_path = os.getcwd()

    try:
        os.chdir(path)
        yield
    finally:
        os.chdir(old_path)
```

### Переваги використання @contextmanager

- Лаконічність: `@contextmanager` робить код більш лаконічним, адже не потрібно вручну писати методи `__enter__` та `__exit__`.
- Читабельність: Код стає більш читабельним, оскільки логіка керування контекстом чітко відокремлена від основної логіки функції.
- Зниження помилок: `@contextmanager` допомагає уникнути помилок, пов'язаних з ручним керуванням ресурсами.

## Використання менеджеру контексту

```py
print(getcwd())  # D:\Vlad\Programming\Python\

with change_directory("/"):
    print(getcwd())  # D:\

print(getcwd())  # D:\Vlad\Programming\Python\
```

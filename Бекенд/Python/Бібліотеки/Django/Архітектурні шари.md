# Архітектурні шари

Одним з ключових аспектів Django є його архітектура, яка базується на розділенні відповідальностей між різними шарами. Це допомагає підтримувати код чистим, зрозумілим та легким для підтримки. Правильне розподілення логіки між архітектурними шарами допомагає створити добре структуровані та надійні веб-застосунки.

## Основні архітектурні шари

Django складається з кількох архітектурних шарів, кожен з яких має свою роль та відповідальність:

-   Модель (Model): Мінімальна логіка роботи з базою даних, такі як геттер/сеттер методи та обчислення значень полів.
-   Менеджер (Manager): Складні запити та маніпуляції з даними, які не підходять для рівня моделі.
-   Представлення (Views): Логіка, що стосується безпосередньої обробки запиту та виклику сервісів.
-   Форма/Серіалізатор: Валідація та перетворення даних між форматами.
-   Сервіс (Service): Бізнес-логіка та складні операції, що не відносяться до конкретної моделі або в'ю.
-   Сигнали (Signals): Виконання логіки у відповідь на певні події в системі, але слід уникати надмірного використання.

## Модель (Model)

-   Завдання: Відповідає за визначення структури бази даних, представляє таблиці бази даних і використовує ORM (Object-Relational Mapping) для взаємодії з базою даних.
-   Логіка: Логіка роботи з базою даних, включаючи методи для взаємодії з даними, але без складної бізнес-логіки. Наприклад, методи для отримання конкретних записів або обчислення значень на основі полів моделі.

```py
from django.db import models

class User(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    age = models.IntegerField()
    email = models.EmailField()

    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"
```

## Менеджер (Manager)

-   Завдання: Відповідає за виконання запитів до бази даних.
-   Логіка: Логіка для складних запитів та маніпуляцій з даними. Наприклад, методи для отримання популярних об'єктів, фільтрація записів за специфічними критеріями.

```py
from django.db import models

class ProductManager(models.Manager):
    def popular_products(self):
        return self.filter(is_popular=True)

class Product(models.Model):
    name = models.CharField(max_length=255)
    is_popular = models.BooleanField(default=False)

    objects = ProductManager()
```

## Представлення (View)

-   Завдання: Відповідає за обробку HTTP-запитів та повернення HTTP-відповідей.
-   Логіка: Мінімальна логіка, що стосується безпосередньої обробки запиту, виклику відповідних сервісів та передачі даних у серіалізатори/форми. Основна бізнес-логіка не повинна знаходитися у в'ю.

```py
from django.shortcuts import render
from .services.payment_service import PaymentService

def process_payment_view(request):
    user = request.user
    amount = request.POST.get('amount')
    PaymentService.process_payment(user, amount)
    return render(request, 'payment_success.html')
```

## Форма (Form)

-   Завдання: Відповідає за валідацію та обробку даних, що вводяться користувачем через HTML-форми.
-   Логіка: Логіка валідації даних та їх обробки перед збереженням у базу даних.

```py
from django import forms
from .models import User

class UserForm(forms.ModelForm):
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'age', 'email']
```

## Серіалізатор (Serializer)

-   Завдання: Відповідає за перетворення складних типів даних у прості формати (наприклад, JSON), а також за валідацію даних.
-   Логіка: Логіка валідації даних та їх перетворення між різними форматами.

```py
from rest_framework import serializers
from .models import User

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'age', 'email']
```

## Шаблон (Template)

-   Завдання: Відповідає за відображення даних у HTML-форматі.
-   Логіка: Мінімальна логіка для відображення даних, більшість логіки має бути у в'ю або сервісах.

```
{% for product in products %}
  <p>{{ product.name }}</p>
{% endfor %}
```

## Сервіс (Service)

-   Завдання: Виконує бізнес-логіку та складні операції, які потребують взаємодії між різними частинами системи.
-   Логіка: Бізнес-логіка, що включає складні операції та алгоритми, які не відносяться до конкретної моделі або в'ю. Наприклад, логіка для обробки платежів, генерації звітів, інтеграції з зовнішніми API.

```py
# services/payment_service.py

class PaymentService:
    def process_payment(self, user, amount):
        if not self._validate_payment(user, amount):
            raise ValueError("Invalid payment details")
        self._execute_payment(user, amount)

    def _validate_payment(self, user, amount):
        return True

    def _execute_payment(self, user, amount):
        pass
```

## Сигнали (Signals)

Сигнали можуть бути корисними для відокремлення коду, який повинен виконуватися у відповідь на події, наприклад, створення або оновлення записів. Проте, надмірне використання сигналів може ускладнити розуміння та налагодження коду. Зазвичай краще викликати методи сервісів у представленнях або інших частинах коду, де це необхідно, щоб зберігати логіку більш явною та керованою.

```py
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import User

@receiver(post_save, sender=User)
def user_post_save(sender, instance, created, **kwargs):
    if created:
        # Виконати певну логіку після створення користувача
        pass
```

# Хуки

Хуки — це функції, що використовуються в React для роботи зі станом, життєвим циклом та контекстом компонентів. Вони надають можливість функціональним компонентам мати внутрішній стан, виконувати побічні ефекти та отримувати доступ до значень контексту. Хуки є просто функціями, але React відстежує їх виклики та може змінювати їхню поведінку та результат виконання.

## Мета хуків

-   Запровадити новий підхід до роботи зі станом та життєвим циклом в React.
-   Зменшити обсяг коду, необхідного для реалізації функціональних компонентів.
-   Спростити перевикористання коду та уникнути проблем, пов'язаних з використанням багатошарових компонентів.
-   Додати функціональним компонентам можливості, що раніше були доступні лише класовим компонентам, такі як внутрішній стан, побічні ефекти та методи життєвого циклу.

## Правила та обмеження хуків

-   Хуки повинні викликатись лише на верхньому рівні функціонального компонента або в інших хуках. Не можна використовувати хуки всередині умовних операторів, циклів або звичайних функцій.
-   Хуки можуть використовуватись лише в функціональних компонентах React. Вони не можуть бути використані в класових компонентах або звичайних функціях.
-   Хуки мають визначену послідовність викликів в межах функціонального компонента. Не можна змінювати порядок викликів хуків.
-   Деякі методи життєвого циклу класових компонентів не підтримуються хуками, такі як `getSnapshotBeforeUpdate`, `getDerivedStateFromError` та `componentDidCatch`.

## Основні хуки

### `useState`

Хук `useState` дозволяє функціональним компонентам мати внутрішній стан. Він повертає поточне значення стану та функцію для його оновлення. Кожний виклик функції оновлення змінює стан компонента.

**Приклад**

```jsx
const [count, setCount] = useState(0);

const increment = () => {
    setCount(count + 1);
};

return <button onClick={increment}>Increment</button>;
```

### `useEffect`

Хук `useEffect` дозволяє виконувати побічні ефекти в функціональних компонентах. Він приймає два параметри: функцію ефекту та масив залежностей. Функція ефекту буде викликана після кожного перемальовування компонента або при зміні значень залежностей. Функція ефекту також може повертати іншу функцію, яка буде викликана для очищення попереднього ефекту.

**Приклад**

Складно пам'ятати, які `props` і `state` використовуються функцією поза ефектом. Саме тому краще оголошувати функції потрібні ефекту всередині нього. Тоді легше побачити, від яких значень із області видимості компонента залежить ефект.

```jsx
useEffect(() => {
    const doSomething = () => console.log(someProp);

    // Виконання побічного ефекту
    doSomething();

    return () => {
        // Очищення попереднього ефекту
    };
}, [dependency]);
```

### `useLayoutEffect`

`useEffect` і `useLayoutEffect` — це два хуки в бібліотеці React, які дозволяють вам взаємодіяти з життєвим циклом компонента. Основна різниця між ними полягає в тому, коли вони виконуються під час оновлення компонента.

1. `useEffect`:
    - `useEffect` — виконується після того, як React відображає зміни на екрані, тобто після змін в DOM.
    - Використовуйте `useEffect`, коли вам не потрібно взаємодіяти з DOM безпосередньо під час оновлення компонента, і вам дозволено затримку в виконанні коду.
2. `useLayoutEffect`:
    - `useLayoutEffect` — виконується перед оновленням DOM, тобто перед тим, як зміни відображаються на екрані.
    - Використовуйте `useLayoutEffect`, коли вам потрібно зробити щось з DOM безпосередньо перед тим, як компонент оновиться, і вам важливо, щоб ця робота відбулася якнайшвидше.

Отже, основна відмінність полягає в часі виконання. `useLayoutEffect` — це синхронний хук, який виконується до оновлення DOM, тоді як `useEffect` — асинхронний і виконується після оновлення DOM.

### `useContext`

Хук `useContext` дозволяє функціональним компонентам отримувати значення з контексту React. Він приймає об'єкт контексту та повертає його поточне значення.

-   Контекст потрібний для того, щоб вирішити проблему «глобальних даних».
-   За допомогою контексту ми можемо зробити так, щоб компоненти не створювали об'єкти сервісу, а отримали його.
-   Може бути корисним при реалізації функціоналу підтримки мов, тем або візуального оформлення.
-   Значення в контексті можна оновлювати, як будь-яку іншу властивість компонента.

**Приклад**

```jsx
const value = useContext(MyContext);
```

### `useCallback`

Хук `useCallback` використовується для збереження функції між викликами компонента, якщо дані в масиві залежностей не змінилися. Це корисно, коли функція передається як `props` в дочірні компоненти, оскільки це дозволяє уникнути непотрібного ререндеру дочірніх компонентів при зміні батьківського компонента. Хук `useCallback` повертає закешовану функцію, яка оновлюється лише при зміні залежностей.

**Приклад**

```js
const memoizedCallback = useCallback(() => {
    doSomething(a, b);
}, [a, b]);
```

### `useMemo`

Хук `useMemo` використовується для кешування результату виконання функції між викликами компонента, якщо дані в масиві залежностей не змінилися. Він дозволяє оптимізувати обчислення, які можуть бути важкими або тривалими. Хук `useMemo` повертає закешоване значення, яке оновлюється лише при зміні залежностей.

**Приклад**

```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

### `useReducer`

Хук `useReducer` дозволяє функціональним компонентам мати більш складний стан, що базується на редукторі. Він приймає функцію редуктора та початковий стан, і повертає поточне значення стану та функцію для виклику дій з редуктором.

```jsx
const initialState = {
    count: 0,
    step: 1,
};

const reducer = (state, action) => {
    const { count, step } = state;

    switch (action.type) {
        case "tick":
            return { count: count + step, step };
        case "step":
            return { count, step: action.step };
        default:
            throw new Error("Unknown action type");
    }
};

function Counter() {
    const [state, dispatch] = useReducer(reducer, initialState);
    const { count, step } = state;

    useEffect(() => {
        const id = setInterval(() => {
            dispatch({ type: "tick" });
        }, 1000);
        return () => clearInterval(id);
    }, [dispatch]);

    return (
        <>
            <h1>{count}</h1>
            <input
                value={step}
                onChange={(e) => {
                    dispatch({
                        type: "step",
                        step: Number(e.target.value),
                    });
                }}
            />
        </>
    );
}
```

### `useRef`

Хук `useRef` дозволяє створювати посилання, які залишаються незмінними між перемальовуваннями компонента. Він корисний для зберігання будь-яких значень, що потрібно зберігати між викликами ефектів або для отримання доступу до DOM-елементів.

```jsx
function MyComponent() {
    const inputRef = useRef(null);

    useEffect(() => {
        inputRef.current.focus();
    }, []);

    return <input ref={inputRef} type="text" />;
}
```

#### Колбек-посилання (Callback Ref)

Колбек-посилання — це один з простих способів отримати доступ до DOM-вузла або елементу React. Ви можете використовувати колбек, коли вам потрібно виконати дії з DOM-елементом після його монтажу або оновлення. Коли посилання прив'язується до елемента, React викликає переданий колбек-функцію, що дозволяє вам працювати з елементом.

```jsx
function TextInputWithFocusButton() {
    const inputRef = useRef(null);

    const onButtonClick = () => {
        inputRef.current.focus();
    };

    return (
        <>
            <input ref={inputRef} type="text" />
            <button onClick={onButtonClick}>Set focus to input</button>
        </>
    );
}
```

#### `forwardRef`

`forwardRef` дозволяє передавати `ref` з батьківського компонента до дочірнього компонента, який передається як `props`. Це корисно, коли ви хочете отримати доступ до DOM-елемента, який знаходиться в дочірньому компоненті, або використовувати методи, які надаються дочірнім компонентом через `ref`.

```tsx
const ChildComponent = forwardRef(function (props, ref) {
    // Використання ref в дочірньому компоненті
    return <input ref={ref} />;
});

const ParentComponent = () => {
    const inputRef = useRef();

    const handleClick = () => {
        // Виклик методу в дочірньому компоненті за допомогою ref
        inputRef.current.focus();
    };

    return (
        <div>
            <ChildComponent ref={inputRef} />
            <button onClick={handleClick}>Focus Input</button>
        </div>
    );
};
```

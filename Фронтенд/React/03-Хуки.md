# Хуки

Хук — функція, що викликається при кожному перемальовуванні компонента. Дає можливість компонентам-функціям працювати зі станом, життєвим циклом і контекстом, технічно це просто функції. Ім'я такої функції починається з use. React відстежує виклики цих функцій і при необхідності може змінити їхню поведінку та змінити результат виконання

## Мета

-   Запросити поріг входу у React
-   Мінімізувати код програми
-   Спростити перевикористання коду та позбутися HOC Wrapper Hell
-   Додати функціональним компонентам відсутні можливості
    -   Внутрішній стан
    -   Виконання сайд-ефектів
    -   Методи життєвого циклу

## Правила та обмеження

-   У компонентах важлива послідовність застосування хуків
-   Не можна використовувати в умовах та циклах
-   Можна використовувати тільки у компонентах та інших хуках (бо React пов'язує той стан який ми зберігаємо в хуках з конкретним екземпляром конкретного компонента, якщо ми намагаємося викликати хук зі звичайної функції, що не є React-компонентом, то React не знатиме яким чином зберегти ці дані, а потім коректно повернути їх назад)
-   Не можна застосовувати у класових компонентах
-   Немає підтримки всіх методів життєвого (`getSnapshotBeforeUpdate`, `getDerivedStateFromError`, `componentDidCatch`)

## Види хуків

### useState

-   Додає `state` у функціональні компоненти
-   Повертає масив — поточне значення та функцію для встановлення нового значення
-   Завжди оновлює об'єкт повністю, а не окремі поля як `setState`

```jsx
const [nameInput, setName] = useState(name);
const [emailInput, setEmail] = useState(email);

const setter = (set) => (evt) => {
    set(evt.target.value);
};

return <Input value={nameInput} onChange={setter(setName)} required />;
```

### useContext

React's Context API — це механізм, який робить одне значення, надане користувачем, доступним для піддерева компонентів. При зміні значення в Provider, всі дочірні компоненти до самого Consumer будуть перемальовані

-   Отримує значення із заданого контексту
-   Код створення контексту та встановлення значення залишається без змін
-   В `useContext` передається саме об'єкт-контекст (а не Consumer)
-   Застосування
    -   Контекст потрібний для того, щоб вирішити проблему «глобальних даних»
    -   Замість того, щоб передавати `props` через усі шари програми, дані можна передавати через контекст
    -   З допомогою контексту ми зможемо зробити так щоб компоненти не створювали об'єкти сервісу, а отримали його
    -   Може бути корисним при реалізації функціоналу підтримки мов, тем або візуального оформлення
    -   Значення в контексті можна оновлювати, як будь-яку іншу властивість компонента

### useEffect

-   Першим параметром приймає callback, другим масив залежностей при зміні яких буде викликатись даний хук
-   Запускає функцію щоразу, коли певний набір даних змінився
-   Якщо дані залежить від параметра (наприклад, id ресурсу) — потрібно вказувати їх у масиві
-   Якщо хочемо викликати використання ефекту один раз, потрібно передати порожній масив
-   Якщо callback повертає ще одну функцію callback, вона буде викликатися для очищення попереднього ефекту (схоже на `componentWillUnmount`)

```jsx
/** Складно пам'ятати, які props і стан використовуються
 * функцією поза ефектом. Саме тому краще оголошувати
 * функції потрібні ефекту всередині нього. Тоді легше
 * побачити, від яких значень із області видимості
 * компонента залежить ефект.
 *
 */
function Example({ someProp }) {
    useEffect(() => {
        const doSomething = () => {
            console.log(someProp);
        };

        doSomething();
    }, [someProp]);
}
```

```jsx
function CounterBad() {
    const [count, setCount] = useState(0);

    useEffect(() => {
        const id = setInterval(() => {
            setCount(count + 1);
        }, 1000);
        return () => clearInterval(id);
    }, [count]);
}

function CounterGood() {
    const [count, setCount] = useState(0);

    useEffect(() => {
        const id = setInterval(() => {
            setCount((count) => count + 1);
        }, 1000);
        return () => clearInterval(id);
    }, []);
}
```

```jsx
/**
 * Скасувати fetch виклик.
 */
function Component({ id }) {
    const [data, setData] = useState();

    useEffect(() => {
        let cancelled = false;

        (async () => {
            const response = await fetch(url + id);
            const data = await response.json();

            !cancelled && setData(film);
        })();

        return () => {
            cancelled = true;
        };
    }, [id]);
}

function Component({ id }) {
    const [data, setData] = useState();

    useEffect(() => {
        const controller = new AbortController();
        const { signal } = controller;

        (async () => {
            const response = await fetch(url + id, { signal });
            const data = await response.json();

            setData(film);
        })();

        return () => controller.abort();
    }, [id]);
}
```

### useLayoutEffect

Швидке емпіричне правило полягає в тому, щоб використовувати `useLayoutEffect`, якщо ефект має бути синхронним, а також якщо є будь-які прямі мутації в DOM. Оскільки це трапляється досить рідко, `useEffect` зазвичай є найкращим варіантом. `useEffect` працює асинхронно

### useCallback

-   Зберігає функцію між викликами, якщо дані в масиві залежностей не змінилися
-   Використовується досить часто, коли хуки залежать від функції. Створювати нову функцію щоразу, як правило, не має сенсу, більше того, це може призвести до неправильної роботи програми. Потрібно використовувати хук useCallback, який запам'ятовує значення переданої функції і оновлює її лише тоді, коли дані у масиві змінилися з минулого виклику

```js
/**
 * f — функція з першого аргументу.
 */
const f = useCallback(() => loadData(id), [id]);
```

```js
/**
 * Реалізація useCallback «під капотом».
 */
const prevState = {
    callback: null,
    deps: null,
};

const useCallback = (callback, deps) => {
    if (!prevState.deps || !deps) {
        prevState.callback = callback;
        prevState.deps = deps;

        return callback;
    }

    if (shallowEqual(deps, prevState.deps)) {
        return prevState.callback;
    }

    prevState.callback = callback;
    prevState.deps = deps;

    return callback;
};
```

### useMemo

-   Зберігає значення між викликами, якщо дані в масиві залежностей не змінилися
-   Працює практично так само як і хук `useCallback`, тільки `useCallback` кешує саму функцію, а `useMemo` кешує результат роботи цієї функції (оптимізація коду, щоб величезне обчислення не відбувалося кожного ререндеру, якщо не змінилися залежності)
-   Може закешувати об'єкт (якщо в `useEffect` залежність — об'єкт, при порівнянні однакових об'єктів отримаємо false, тут допомагає `useMemo`)

```js
/**
 * f — результат роботи функції з першого аргументу.
 */
const f = useMemo(() => getValue(id), [id]);
```

### useReducer

-   Зазвичай використовується замість `useState`, коли у вас складна логіка стану, яка включає кілька значень, або коли наступний стан залежить від попереднього
-   Дозволяє винести логіку в окремий файл

```jsx
function CounterBad() {
    const [count, setCount] = useState(0);
    const [step, setStep] = useState(1);

    useEffect(() => {
        const id = setInterval(() => {
            setCount((c) => c + step);
        }, 1000);
        return () => clearInterval(id);
    }, [step]);

    return (
        <>
            <h1>{count}</h1>
            <input
                value={step}
                onChange={(evt) => setStep(Number(evt.target.value))}
            />
        </>
    );
}

function CounterGood() {
    const [state, dispatch] = useReducer(reducer, initialState);
    const { count, step } = state;

    useEffect(() => {
        const id = setInterval(() => {
            dispatch({ type: "tick" });
        }, 1000);
        return () => clearInterval(id);
    }, [dispatch]);

    return (
        <>
            <h1>{count}</h1>
            <input
                value={step}
                onChange={(e) => {
                    dispatch({
                        type: "step",
                        step: Number(e.target.value),
                    });
                }}
            />
        </>
    );
}

const initialState = {
    count: 0,
    step: 1,
};

function reducer(state, action) {
    const { count, step } = state;

    switch (action.type) {
        case "tick":
            return { count: count + step, step };
        case "step":
            return { count, step: action.step };
        default:
            throw new Error("Unknown action type");
    }
}
```

```jsx
const initialState = { count: 0 };

function reducer(state, action) {
    switch (action.type) {
        case "increment":
            return { count: state.count + 1 };
        case "decrement":
            return { count: state.count - 1 };
        default:
            throw new Error();
    }
}

function Counter() {
    const [state, dispatch] = useReducer(reducer, initialState);
    return (
        <>
            Count: {state.count}
            <button onClick={() => dispatch({ type: "decrement" })}>-</button>
            <button onClick={() => dispatch({ type: "increment" })}>+</button>
        </>
    );
}
```

### useRef

Не можна звертатися до DOM-елементу напряму, тому що з DOM працює React. До того ж, ми не можемо бути впевнені, що коли ми звернемося до елементу за допомоги `document.querySelector`, VirtualDOM вже відмалює потрібний нам DOM-елемент, тому ми повинні використовувати `ref` у такому випадку

-   Дає можливість отримати доступ до DOM-вузлів або React-елементів, створених у render-методі
-   Створює стан так само як і `useState`, особливість в тому, що ми отримуємо об'єкт, а не дві змінні
-   Зберігає дані між перемальовками
-   Допомагає керувати фокусом, виділяти текст або програвання медіа
-   Допомагає з імперативним викликом анімацій
-   Допомагає зробити інтеграцію зі сторонніми DOM-бібліотеками
-   Корисний якщо форма з великою кількістю контролів (браузер добре працює з формами)

```jsx
/**
 * Компонент має бути вже намальований на сторінці
 */
class MyComponent extends React.Component {
    componentDidMount() {
        const input = this._inputRef.current.focus();
    }
}
```

```jsx
/**
 * callback-ref.
 *
 * Один з елементарних способів визначення положення
 * або розміру DOM-вузла це використання callback-ref.
 * React буде викликати цей колбек щоразу, коли реф
 * прив'язується до іншого вузла.
 */
function TextInputWithFocusButton() {
    const inputEl = useRef(null);
    const onButtonClick = () => {
        inputEl.current.focus(); // current вказує на змонтований елемент input
    };

    return (
        <>
            <input ref={inputEl} type="text" />
            <button onClick={onButtonClick}>Set focus to input</button>
        </>
    );
}
```

```tsx
/**
 * forwardRef корисний, якщо ви загортаєте базові компоненти
 * в проксі-компоненти, але хочете використовувати
 * властивість ref так само, як ви звикли.
 */
type ButtonProps = ComponentPropsWithRef<'button'>;

const Button = forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => (
    <button type="button" {...props} ref={ref}>{props.children}</button>
)));

//  Ви можете використовувати свій проксі так само, як і звичайну кнопку!
const reference = createRef<HTMLButtonElement>();
<Button className="primary" ref={reference}>Hello</Button>;
```

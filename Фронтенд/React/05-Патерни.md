# Патерни (шаблони проектування)

Патерни проектування — це готові способи рішення певних проблем та підходи до написання коду. Вони допомагають організувати код, зробити його більш зрозумілим, перевикористовуваним та підтримуваним.

## Односпрямований потік даних

Цей патерн передбачає передачу даних в одному напрямку — від батьківських компонентів до дочірніх компонентів через властивість `props`. Це означає, що дані змінюються тільки в батьківських компонентах, а дочірні компоненти можуть лише отримувати ці дані і відображати їх. Цей підхід сприяє простоті управління станом застосунку та зменшенню складності.

## Умовний рендеринг

Умовний рендеринг — це метод, який дозволяє вибирати, який компонент рендерити на основі певної умови. Це може бути досягнуто за допомогою операторів умови (наприклад, `if` або `switch`) або за допомогою логічних операторів (`&&`, `||`).

**Приклад**

```jsx
const element1 = product.type || `Артикул ${product.id}`;
const element2 = product.type && <mark>product.type<mark>;
```

## Елементи-властивості

Цей патерн дозволяє передавати React-елементи як значення властивостей. Це дозволяє створювати компоненти-контейнери або компоненти, які можуть вибирати, що рендерити на основі переданого елемента. Наприклад, можна передати React-елемент як властивість `title` для створення елементів «контейнерів» або умовного рендерингу.

**Приклад**

```jsx
const card = <Card title={<p>Hello</p>} />;
```

## Render-функція

Цей патерн передбачає передачу функції в React-компонент, яка відповідає за рендеринг певних частин компонента або його повного рендерингу. Це дозволяє компонентам мати більшу гнучкість і перевикористовуваність, оскільки рендер-функція може бути змінювана або переоприділена в різних контекстах. Рендер-функція може приймати аргументи, на які можна спиратися вище по ієрархії та робити потрібні зміни.

**Приклад**

```jsx
const card = <Card renderBody={(id) => <p>Card id: {id}</p>} />;
```

## Композиція

Композиція — це підхід, при якому компоненти об'єднуються для створення нових компонентів. Це дозволяє перевикористовувати код і створювати більш складні компоненти шляхом комбінування менших компонентів.

## Higher Order Component (Компонент вищого порядку)

Higher Order Component (HOC) — це функція, яка приймає компонент і повертає новий компонент, розширяючи його функціональність. HOC дозволяють додавати додаткову логіку до компонентів, наприклад, обгортати їх в контейнери, додавати стилі або керувати станом.

### Мета використання HOC

-   Створення нових компонентів.
-   Повторне використання коду.
-   Збереження локального стану компонентів.

### Важливо пам'ятати

-   Зміна HOC місцями може призвести до неправильної роботи.
-   Передані `props` — неявні залежності. Важко зрозуміти, звідки приходять `props`, в порівнянні з імпортом поведінки безпосередньо, від якого залежать компоненти, що його використовують.
-   Використання багатьох HOC з великою кількістю `props` може призвести до колізій `props`

### Коли використовувати HOC

-   Поведінка потрібна не лише для одного компонента, а для багатьох компонентів у застосунку.
-   Поведінка не вимагає додавання багатьох `props`, що використовують цю поведінку.
-   Компоненти можуть функціонувати самостійно, без цієї поведінки HOC.
-   Немає потреби додавати логіку безпосередньо до компонента, який обгортається HOC.

### Коли не використовувати HOC

-   Поведінка вимагає додавання багатьох `props` до компонентів.
-   Поведінка застосовується лише до одного конкретного компонента.
-   Поведінка повинна налаштовуватись для кожного компонента, який використовує цю поведінку.

### Композиція HOC

-   Композиція — це застосування однієї функції до результату іншої.
-   Можна використовувати кілька HOC для створення більш складених компонентів.

### Трансформація властивостей

-   HOC може перетворити властивості, перед тим як передавати їх компоненту (наприклад, змінювати їх імена або вибирати певні властивості).
-   За допомогою додаткової функції (`mapMethodsToProps`) можна визначати цю поведінку для кожного компонента.

### Імпорт HOC

Можна обгорнути компонент HOC під час імпорту чи експорту. Якщо використовувати HOC під час експорту, потрібно написати експорт двічі:

-   Експорт компонента, обгорнутого HOC, як дефолтний експорт.
-   Звичайний експорт «чистого» компонента.

## Проксі-компонент

Проксі-компонент — це компонент вищого рівня, який передає `props` до компонента на рівень нижче. Використовується, коли потрібно розширити функціональність компонента, але зберегти гнучкість і читабельність коду.

## HOC vs проксі-компонент

-   Зворотний бік «гнучкості» компонентів це громіздка конфігурація.
-   Код буде більш читабельним, якщо винести деталі конфігурації в окремі компоненти, для цього можна використовувати HOC або просто написати проксі-компонент вручну.

```jsx
function Button({ title, handleClick }) {
    return <button onClick={handleClick}>{title}</button>;
}

/**
 * HOC.
 *
 * Використовуючи такий підхід, ми можемо надати
 * будь-якому компоненту (<Button />, <Card />, <Logo />)
 * додаткову функціональність (виклик alert).
 */
const withAlert = (Component) => {
    return (props) => {
        const { alertMessage, handleClick = () => {} } = props;

        return (
            <Component
                {...props}
                handleClick={() => {
                    handleClick();
                    alert(alertMessage);
                }}
            />
        );
    };
};

/**
 * Проксі-компонент.
 *
 * Використовуючи такий підхід, потрібно створити
 * нові компоненти (<AlertButton />, <AlertButtonCard />,
 * <AlertButtonLogo />), щоб додати додаткову
 * функціональність (виклик alert).
 */
function AlertButton({ title, handleClick, alertMessage }) {
    return (
        <Button
            title={title}
            handleClick={() => {
                handleClick();
                alert(alertMessage);
            }}
        />
    );
}
```

## Компонент-контейнер

Компонент-контейнер — це компонент, який відповідає за обробку даних та бізнес-логіки, тоді як презентаційні компоненти відповідають лише за відображення даних. Компонент-контейнери допомагають розділити логіку та відображення для покращення перевикористовуваності та підтримки коду.

## Memoization (мемоізація)

Мемоізація — це техніка збереження результатів виконання функцій для запобігання повторним обчисленням. В React мемоізація може бути досягнута за допомогою `React.memo()` для компонентів, `React.useCallback()` для кешування колбеків та `React.useMemo()` для кешування складних обчислень. Це допомагає зменшити непотрібні перерендеринги та покращити продуктивність застосунку.

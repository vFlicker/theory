# Рендеринг

Рендеринг — роцес React, який просить ваші компоненти описати, як вони хочуть, щоб їхній інтерфейсу користувача зараз виглядав на основі поточної комбінації `props` і `state`

1. Порівняння нового і старого Virtual-DOM, на основі їх відмінностей заміна елементів в DOM
    1. «Фаза візуалізації» — містить усю роботу з відтворення компонентів і обчислення змін
    1. «Фаза фіксації» — процес застосування цих змін до DOM
1. Запускає `componentDidMount`, `componentDidUpdate`, `useLayoutEffect`, а через маленький таймаут `useEffect`

Коли ми зробимо зміни `state` в `<App />`, React викличе `render`, для всіх дочірніх компонентів `<App />`, так React узнає, чи потрібно насправді вносити будь-які зміни в DOM

## Lazy initializers

Callbacks, що передаються до `useState` і `useReducer`

## Virtual DOM (Віртуальний ДОМ)

Дерево іммутабельних елементів React, що повертається з методу `render`

## Reconciliation (звірка)

-   Звіряння — алгоритм React, який використовується для того, щоб відрізнити одне дерево елементів від іншого для визначення частин, які потрібно буде замінити
-   Апдейт — зміна даних, які використовуються для відображення програми React. Зазвичай це результат виклику методу `setState`; кінцевий результат відтворення компонента

## Fiber

-   Планування — процес, який визначає коли робота має бути виконана
-   Робота — будь-які обчислення, які мають бути виконані. Робота — це зазвичай результат апдейту (наприклад, виклик `setState`)

## Пропуск візуалізації

-   Зсередини компоненту
    -   `Component.shouldComponentUpdate`
    -   `PureComponent`
    -   `memo`
-   Ззовні компоненту
    -   `props.children`
    -   `useMemo`

```jsx
function ExpensiveChildComponent() {
    console.log("render ExpensiveChildComponent");
    return <h1>ExpensiveChildComponent</h1>;
}

function SomeProvider({ children }) {
    const [counter, setCounter] = useState(0);

    return (
        <div>
            <button onClick={() => setCounter(counter + 1)}>
                Count: {counter}
            </button>
            <ExpensiveChildComponent /> {/* Буде ререндер */}
            {children} {/* Не буде ререндеру */}
        </div>
    );
}

function OptimizedParent() {
    const [counter1, setCounter1] = useState(0);
    const [counter2, setCounter2] = useState(0);

    const memoizedElement = useMemo(() => {
        // Буде ререндер тільки якщо клікнути на Counter 1
        return <ExpensiveChildComponent />;
    }, [counter1]);

    return (
        <div>
            <button onClick={() => setCounter1(counter1 + 1)}>
                Counter 1: {counter1}
            </button>
            <button onClick={() => setCounter2(counter2 + 1)}>
                Counter 2: {counter2}
            </button>
            {memoizedElement}
        </div>
    );
}

export function App() {
    return (
        <div className="App">
            <SomeProvider>
                <ExpensiveChildComponent />
            </SomeProvider>
            <OptimizedParent />
        </div>
    );
}
```

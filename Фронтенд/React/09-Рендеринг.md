# Рендеринг

Рендеринг в React — це процес, в якому React просить ваші компоненти описати, як їхній інтерфейс користувача має виглядати в залежності від поточної комбінації `props` і `state`.

1. Порівняння нового і старого Virtual DOM — React порівнює нове дерево Virtual DOM з попередньою версією, знаходячи відмінності між ними і визначаючи, які елементи потрібно оновити, додати або видалити в реальному DOM.
    - «Фаза віртуалізації» — цей процес включає в себе роботу з компонентами та обчислення змін.
    - «Фаза фіксації» — у цій фазі React застосовує знайдені зміни до реального DOM.
2. Виклик ефектів життєвого циклу — після оновлення DOM React викликає методи життєвого циклу, такі як `componentDidMount`, `componentDidUpdate`, `useLayoutEffect` (якщо використовуються) та `useEffect` з невеликим затримкою.

<img src="./_images/rendering.png" />

Коли ми змінюємо `state` в компоненті `<App />`, React викликає метод `render` для всіх дочірніх компонентів `<App />`. Це дозволяє React визначити, чи потрібно насправді змінювати реальний DOM.

## Ліниві ініціалізатори

Це зворотні виклики, які передаються у `useState` та `useReducer`. Вони використовуються для лінивого створення початкових значень стану або редукторів.

## Віртуальний DOM

Віртуальний DOM — це дерево імутабельних елементів React, яке повертається з методу `render` компонента. Він представляє структуру компонентів та їх властивостей.

## Звірка (Reconciliation)

-   Звірка — це алгоритм React, який використовується для порівняння двох дерев віртуального DOM для визначення частин, які потрібно оновити.
-   Апдейт — це зміна даних, які використовуються для відображення компонента React. Зазвичай це результат виклику методу `setState` або зміни значень пропсів. Кінцевий результат роботи звірки — оновлений віртуальний DOM.

## Fiber

-   Планування — це процес визначення, коли робота має бути виконана. React використовує алгоритм планування, який називається Fiber, для керування роботою в React-застосунках.
-   Робота — це будь-які обчислення, які мають бути виконані. Робота включає в себе роботу з компонентами, вирішення проблем звірки, виклик зворотних викликів життєвого циклу та оновлення реального DOM.

## Пропуск віртуалізації

Пропуск віртуалізації — це механізм оптимізації рендерингу компонентів, коли React визначає, що компонент не потребує повторного рендерингу, оскільки його `props` або `state` не змінилися.

У React є кілька способів реалізації пропуску віртуалізації:

1. Зсередини компоненту:
    - `shouldComponentUpdate` (для класових компонентів) — метод, який визначає, чи потрібно компоненту повторно рендеритись. Він порівнює попередні пропси та стан з поточними і повертає `true` або `false` в залежності від необхідності рендерингу.
    - `React.memo` (для функціональних компонентів) — функція-обгортка, яка перевіряє, чи змінилися пропси компонента перед його рендерингом. Якщо пропси не змінилися, компонент повертається з пам'яті, із запам'ятованим результатом рендерингу.
2. Ззовні компоненту:
    - `children` властивість — якщо `children` не змінився, React не буде повторно рендерити компонент.
    - `React.useMemo` (для хуків) — xук `useMemo` дозволяє кешувати результат обчислень і повертати його, якщо залежності не змінилися. Це дозволяє уникнути повторного розрахунку результату, якщо `props` або інші залежності не змінилися.

```jsx
import React, { useState, useMemo } from "react";

function ExpensiveChildComponent() {
    console.log("render ExpensiveChildComponent");
    return <h1>ExpensiveChildComponent</h1>;
}

function SomeProvider({ children }) {
    const [counter, setCounter] = useState(0);

    return (
        <div>
            <button onClick={() => setCounter(counter + 1)}>
                Count: {counter}
            </button>
            <ExpensiveChildComponent /> {/* Буде ререндер */}
            {children} {/* Не буде ререндеру */}
        </div>
    );
}

function OptimizedParent() {
    const [counter1, setCounter1] = useState(0);
    const [counter2, setCounter2] = useState(0);

    const memoizedElement = useMemo(() => {
        // Буде ререндер тільки якщо клікнути на Counter 1
        return <ExpensiveChildComponent />;
    }, [counter1]);

    return (
        <div>
            <button onClick={() => setCounter1(counter1 + 1)}>
                Counter 1: {counter1}
            </button>
            <button onClick={() => setCounter2(counter2 + 1)}>
                Counter 2: {counter2}
            </button>
            {memoizedElement}
        </div>
    );
}

export function App() {
    return (
        <div className="App">
            <SomeProvider>
                <ExpensiveChildComponent />
            </SomeProvider>
            <OptimizedParent />
        </div>
    );
}
```

В цьому прикладі показані компоненти `ExpensiveChildComponent`, `SomeProvider` і `OptimizedParent`, що демонструють різні ситуації з пропуском віртуалізації.

`ExpensiveChildComponent` — це компонент, який вважається «дорогим» для рендерингу, оскільки виводить повідомлення в консоль при кожному рендері.

У компоненті `SomeProvider` ми маємо `ExpensiveChildComponent` як дочірній компонент, і він буде ререндеритись при кожному оновленні `SomeProvider`. Однак, пропси `children`, які передаються до `SomeProvider`, не будуть ререндеритись.

У компоненті `OptimizedParent` ми використовуємо хук `useMemo`, щоб оптимізувати ререндер `ExpensiveChildComponent`. Компонент буде ререндеритись лише при зміні `counter1`, а не при зміні `counter2`.

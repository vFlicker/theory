# Компоненти

Інтерфейси користувача складаються з компонентів — незалежних блоків, які можуть мати власну поведінку та розмір.

## React-компоненти

У React компоненти — це функції, які приймають аргументи (`props`) та повертають React-елемент (JSX). Імена компонентів мають починатися з великої літери. Потім ці імена можна використовувати у JSX як HTML теги.

## Props

Props — це властивості компонентів, які передаються в кожен компонент. Ми можемо передавати будь-які властивості в React-компоненти, щоб отримати дані. Props є об'єктом, який передається всередину кожної функції компонента. Використовуючи Props, компонент може відображати та працювати з цими даними. Масив можна передавати як властивість. Також, можна передавати всі властивості об'єкта в компонент за допомогою оператора `spread` (не перераховуючи кожну властивість окремо).

```jsx
function List({ item }) {
    return <Item {...item} />;
}
```

### Зайві Props

Компонент повинен отримувати тільки ті дані, які йому потрібні. Не треба передавати в Props властивість, якщо вона йому не потрібна.

### Оголошення типів Props та State

Зазвичай, типи Props та State оголошують вгорі файлу з компонентом, а те, на основі чого вони збираються, зберігають в окремій директорії (наприклад, "types" на рівні reducers, selectors).

## React.Fragment

React.Fragment дозволяє групувати елементи без створення зайвих DOM-об'єктів. Він допомагає уникнути додаткових обгорток у HTML-структурі, що полегшує роботу з компонентами.

```jsx
function App() {
    return (
        <React.Fragment>
            <Header />
            <Content />
            <Footer />
        </React.Fragment>
    );
}
```

### React.Children

-   Функція `React.Children.map()` полегшує обробку `props.children` шляхом ітерації по кожному дочірньому елементу.
-   Дочірні елементи можна замінювати, обгортати в інші компоненти або приховувати (повертаючи `null`).
-   Функція `cloneElement` дозволяє склонувати та повернути новий React-елемент, розширюючи або змінюючи його властивості, використовуючи існуючий елемент як вихідний.

```jsx
export const ItemDetails = ({ data, children }) => {
    const itemList = React.Children.map(children, (child) => {
        return React.cloneElement(child, { data });
    });

    return <div>{itemList}</div>;
};
```

У даному прикладі компонент `ItemDetails` отримує `data` і `children` через пропси. Він використовує `React.Children.map()` для обробки кожного дочірнього елементу. Кожен дочірній елемент клонується за допомогою `React.cloneElement()` і розширюється новою властивістю `data`. Результат обробки відображається у вигляді списку елементів, обгорнутих в `<div>`.

## Колекції та ключі

При відображенні колекцій (наприклад, масиву елементів) у React, кожному елементу потрібна унікальна властивість `key`. React використовує ключі для ефективного порівняння та оновлення елементів при оновленні. Важливо, щоб ключі були унікальними всередині однієї колекції. Не рекомендується використовувати індекс масиву як ключ, оскільки це може призводити до неправильного оновлення елементів.

```jsx
function List() {
    const items = ["apple", "banana", "orange"];

    return (
        <ul>
            {items.map((item, index) => (
                <li key={index}>{item}</li>
            ))}
        </ul>
    );
}
```

## Допоміжні компоненти

Більшості застосунків потрібні допоміжні компоненти, такі як ErrorBoundary, Context, HOC. Ці та інші допоміжні компоненти рекомендується створювати заздалегідь до початку роботи над основним функціоналом застосунку. Вони допомагають структурувати та організувати код та спрощують розробку та управління станом застосунку.

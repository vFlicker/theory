# Робота з мережею

Дані в React-Redux застосуноку приходять не з серверу, а з де-якої прокладки BLL (business logic layer)

## API-клієнт

-   Код, який працює з мережею, краще ізолювати в окремий клас-сервіс
-   Компоненти не повинні знати, звідки саме беруться дані
-   Такий підхід спростить тестування та підтримку коду, що працює з API

## Логіка індикатора завантаження

-   Додати поле loading до Redux state
-   Оновлювати це поле в reducer, коли дані стануть доступними
-   Передати значення loading в компонент
-   Залежно від стану loading, рендерити індикатор завантаження або вміст компонента (вже з даними)

## Обробка помилок

-   Помилку отриманих даних, потрібно зберегти в store, потім компонент зможе її відобразити

## Асинхронність

Будь-які запити до мережі не повертають результат миттєво, тому Action не може повернути дані миттєво — потрібно додати якийсь проміжний стан

-   React нічого не знає про роботу з сервером — це завдання інших бібліотек
-   Мережний код слід ізолювати від коду компонентів
-   Якщо необхідно, трансформуйте дані до того, як їх отримає компонент
-   Хороша програма не відображає елементи для яких немає даних
-   Обробляйте стан «завантаження» та «помилка»
-   Розділяйте відповідальність компонентів — логіку та рендеринг
-   Функція, може інкапсулювати отримання даних (тоді компонент стає незалежною від джерела даних)

## Redux Thunk

Пакет redux-thunk — це middleware. З його допомогою ми розширюємо функціональність Redux, отримуючи можливість робити dispatch (надсилати) не тільки об'єкти, що описують дії, а й функції. Такі функції приймають dispatch і getState, у них ми можемо розмістити код із побічними ефектами

```ts
/**
 * У ньому оголошено 3 параметри передачі інформації
 * про типи. Перший: DispatchExt. Для нього визначено
 * значення за замовчуванням у вигляді об'єкта. По ідеї,
 * ми можемо цим скористатися і замість unknown вказати
 * об'єкт. Але це зробити не вийде, тому що лінтер
 * забороняє використовувати універсальний об'єкт.
 * Тому ми вказали unknown, маючи на увазі, що тип
 * буде уточнено пізніше.
 */ d;
export interface Middleware<
    DispatchExt = {},
    S = any,
    D extends Dispatch = Dispatch
> {
    (api: MiddlewareAPI<D, S>): (
        next: Dispatch<AnyAction>
    ) => (action: any) => any;
}
```

```js
const createThunkMiddleware = (extraArgument) => {
    return ({ dispatch, getState }) =>
        (next) =>
        (action) => {
            if (typeof action === "function") {
                return action(dispatch, getState, extraArgument);
            }

            return next(action);
        };
};

const getData = () => (dispatch, _getState, _extraArgument) => {
    return fetch("https://jsonplaceholder.typicode.com/posts")
        .then((response) => response.json())
        .then((json) => {
            /**
             * Навіть middleware зрештою відправлятиме дії
             * з простими об'єктами за допомогою цього
             * методу.
             */
            dispatch({ type: "DATA_LOADED", payload: json });
        });
};
```

## Redux Saga

Пакет redux-saga — це middleware для керування побічними ефектами. З його допомогою ми чітко розділити синхронну та асинхронну логіку

```js
/**
 * store/actions.js
 */
const getData = (id) => ({
    type: "DATA_REQUESTED",
    payload: { id },
});

/**
 * store/sagas.js
 */
import { takeEvery, call, put } from "redux-saga/effects";

const getData = async (id) => {
    const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);
    return await res.json();
};

/**
 * 1. Взяти кожен action з назвою "DATA_REQUESTED" і для
 * кожного з цих action запускати worker saga.
 *
 * 2. Всередині worker saga викликається функція
 * під назвою getData.
 *
 * 3. Якщо функція успішна, тоді надсилаємо новий action
 * з назвою "DATA_LOADED" разом із payload.
 *
 * 4. Якщо функція видає помилку, тоді надсилаємо новий
 * action під назвою "API_ERRORED" разом із payload.
 */
export default function* watcherSaga() {
    yield takeEvery("DATA_REQUESTED", workerSaga);
}

function* workerSaga(action) {
    yield put({ type: "DATA_FETCHING" });

    try {
        const payload = yield call(getData, action.payload.id);
        yield put({ type: "DATA_LOADED", payload });
    } catch (evt) {
        yield put({ type: "API_ERRORED", payload: evt });
    }
}
```

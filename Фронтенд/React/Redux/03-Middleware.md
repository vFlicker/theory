# Middleware

Middleware в Redux - це шар, що знаходиться між відправленням дій (actions) і досягненням їх редукторів (reducers). Вони дозволяють перехоплювати та обробляти дії перед тим, як вони досягнуть редуктора, а також виконувати додаткову логіку, таку як логування, маршрутизація, взаємодія з асинхронними запитами і багато іншого.

## Основні переваги

-   Дозволяє виділити більшість логіки зі зв'язаних з інтерфейсом користувача компонентів.
-   Дозволяє легко додавати, вилучати та замінювати middleware.
-   Забезпечує можливість використовувати окремі тести для кожної програми.

## Використання

-   Логування дій та стану.
-   Модифікація дій перед тим, як вони досягнуть редуктора.
-   Звітування про помилки або збої.
-   Взаємодія з асинхронними API.
-   Маршрутизація.

## Обробка actions

Обробка дій (actions) здійснюється через ланцюжок middleware, де кожен middleware може перехоплювати та обробляти дію перед тим, як вона перейде до наступного middleware або редуктора. Оригінальна функція `dispatch` магазину викликається лише після проходження дії через усі middleware.

## Базова форма middleware

Redux middleware це функція, яка приймає об'єкт з методами `getState` і `dispatch` та повертає функцію, яка приймає `next` як параметр. Потім внутрішня функція повертає іншу функцію, яка приймає `action` як параметр і, нарешті, повертає `next(action)`

```js
/**
 * Якщо вам цікаво прочитати наступний стан програми після
 * запуску middleware, ви можете зафіксувати його
 * за допомогою getState після next(action)
 */
function myMiddleware({ getState, dispatch }) {
    return function (next) {
        return function (action) {
            // Виконайте корисну роботу тут.
            // Передайте дію далі за допомогою next(action),
            // або почніть новий конвеєр за допомогою dispatch(action).

            const nextAction = next(action);

            // Читання наступного стан.
            const state = getState();
            console.log(state);

            // Виклик next(action) пересуває виконання програми далі,
            // передаючи дію наступному middleware в ланцюжку.
            return nextAction;
        };
    };
}
```

При реалізації middleware, можна використовувати методи `getState` і `dispatch` для отримання поточного стану сховища і відправлення нових дій. Ланцюжок middleware може бути сконструйований шляхом повернення вкладених функцій з відповідними обробниками дій.

```js
const forbiddenWords = ["spam", "money"];

const forbiddenWordsMiddleware = ({ dispatch }) => (next) => (action) => {
    if (action.type === ADD_ARTICLE) {
        const foundWord = forbiddenWords.filter((word) =>
            action.payload.includes(word)
        );

        if (foundWord.length) {
            /**
             * Ланцюжок виконання middleware буде перерваний,
             * і виконання почнеться з початку з новою дією.
             *
             * Якщо ми пропустимо return:
             *  1. Middleware почнуть виконання з початку
             *      з дією "TITLE_FORBIDDEN", яка в кінцевому
             *      рахунку потрапить до редуктора.
             *  2. Після виконання редуктора з дією
             *      "TITLE_FORBIDDEN", виконання продовжиться
             *      поточною функцією (виконання рядка return next(action))
             */
            return dispatch(titleForbidden());
        }
    }

    return next(action);
};
```

У цьому прикладі middleware `forbiddenWordsMiddleware` перевіряє, чи містить додана стаття заборонені слова. Якщо заборонені слова знайдені, то викликається дія `titleForbidden()`, яка змусить ланцюжок middleware розпочати виконання з початку з новою дією.

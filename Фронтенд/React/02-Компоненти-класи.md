# Компоненти-класи

React-компоненти можуть бути реалізовані як класи, успадковуючи від базового класу `React.Component`. Вони використовуються, коли потрібно зберігати та оновлювати стан компонента.

## Оголошення компонента-класу

React-компоненти-класи включають методи та властивості, які контролюють їх поведінку та взаємодію з іншими компонентами.

```jsx
class MyComponent extends React.Component {
    render() {
        return <div>Hello, World!</div>;
    }
}
```

## State (стан)

State використовується для зберігання внутрішніх даних компонента. Він ініціалізується в конструкторі компонента або в тілі класу. Після ініціалізації, стан не можна змінити напряму, тільки читати. Для зміни стану використовується метод `setState`, якому передається новий об'єкт стану або функція, яка оновлює стан на основі попереднього стану. Оновлення стану є асинхронним процесом. Після оновлення стану, React викликає метод `render` для оновлення відображення компонента та всіх його нащадків.

```js
class Counter extends React.Component {
    constructor(props) {
        super(props);
        this.state = { count: 0 };
    }

    increment() {
        /**
         * Якщо потрібно встановити стан на основі попереднього
         * стану.
         */
        this.setState((state, props) => {
            return { counter: state.counter + props.step };
        });
    }

    render() {
        return (
            <div>
                Count: {this.state.count}
                <button onClick={() => this.increment()}>Increment</button>
            </div>
        );
    }
}
```

## Система подій

Компоненти можуть генерувати та обробляти власні події. Для передачі функції обробника події в компонент, використовується властивість `props`. Компонент викликає функцію обробника події, коли настає відповідна подія. Це дозволяє компонентам спілкуватися та передавати дані «вгору» по ієрархії компонентів.

```jsx
class Button extends React.Component {
    handleClick() {
        this.props.onButtonClick();
    }

    render() {
        return <button onClick={() => this.handleClick()}>Click me</button>;
    }
}

class App extends React.Component {
    handleButtonClick() {
        console.log("Button clicked");
    }

    render() {
        return <Button onButtonClick={() => this.handleButtonClick()} />;
    }
}
```

## Життєвий цикл компонентів-класів

Життєвий цикл компонентів-класів складається з різних методів, які викликаються на різних етапах існування компонента. Ці методи дозволяють виконувати певний код в певні моменти життєвого циклу компонента, наприклад, під час створення, оновлення або видалення компонента.

### Mount (монтування)

1. `constructor` — викликається під час створення об'єкта компонента. Ініціалізує початковий стан компонента та прив'язує контекст до методів.
2. `getDerivedStateFromProps` — викликається після конструктора та перед рендерингом компонента. Використовується для оновлення стану компонента на основі нових властивостей.
3. `render` — викликається для рендерингу компонента та повертає JSX-елемент.
4. `componentDidMount` — викликається після першого рендерингу компонента та встановлення його на сторінці. Використовується для ініціалізації (запити до сервера, підписка на події тощо).

В ООП вважається поганою практикою, коли `constructor` має side-ефекти (наприклад починає робити запити до сервера), тому що коли у об'єкта є такий конструктор його складніше тестувати і з ним складніше працювати.

До того як React викликає `componentDidMount`, компонент вважається `unmounted` (перебуває у підвішеному стані, об'єкт вже створений, але він ще не до кінця проініціалізований, у дереві компонентів програми, і до того, як компонент стане `mounted`, тобто буде викликаний `componentDidMount`, викликати `setState` не можна (такий виклик до `setState` не буде мати ніякого ефекту). Тому ініціалізацію компонентів, які залежать від зовнішніх джерел даних краще проводити в `componentDidMount`.

### Update (оновлення)

1. `getDerivedStateFromProps` — викликається перед оновленням компонента. Використовується для оновлення стану компонента на основі нових властивостей.
2. `shouldComponentUpdate` — визначає, чи потрібно оновлювати компонент після зміни властивостей або стану. За замовчуванням, компонент оновлюється при кожній зміні. Метод може повернути `false`, щоб заборонити оновлення компонента та оптимізувати його роботу.
3. `render` — викликається для оновлення рендерингу компонента.
4. `componentDidUpdate` — викликається після оновлення компонента. Використовується для виконання післяоновлювальних дій, таких як оновлення стану, взаємодія з DOM тощо.

### Unmount (розмонтування)

1. `componentWillUnmount` — викликається перед видаленням компонента з DOM. Використовується для очищення ресурсів (таймери, підписки на події, запити до сервера тощо).

### Error (помилка)

1. `getDerivedStateFromError` — викликається, коли виникає помилка при рендерингу компонента-нащадка. Використовується для оновлення стану компонента на основі помилки.
2. `componentDidCatch(error, info)` — викликається після того, як компонент-нащадок викидає помилку. Використовується для логування помилок та відображення запасного вмісту в компоненті.

## Методи-стрілки та біндінг

У компонентах-класах потрібно правильно прив'язувати контекст для методів, що використовують `this`. Це можна зробити за допомогою біндінгу методів в конструкторі компонента або використовуючи методи-стрілки. Методи-стрілки автоматично прив'язуються до контексту компонента та не потребують додаткового біндінгу.

Різниця у використанні біндінгу і методу-стрілки у тому, що `this.handlerClick.bind(this)`, ми викликаємо в `constructor`, тому функція створюється всього 1 раз, через Reconciliation-алгоритм React, `constructor` буде викликаний всього 1 раз.

## shouldComponentUpdate vs PureComponent vs React.memo

У React є декілька способів оптимізації оновлення компонентів. Метод `shouldComponentUpdate` дає можливість вручну контролювати, чи потрібно оновлювати компонент після зміни властивостей або стану. Клас `PureComponent` автоматично перевіряє зміни властивостей та стану і оновлює компонент лише при необхідності. Функціональний компонент можна оптимізувати за допомогою `React.memo`, який кешує результати рендерингу та оновлює компонент лише при зміні вхідних властивостей.

```jsx
// shouldComponentUpdate
class Foo extends React.Component {
    shouldComponentUpdate(nextProps, nextState) {
        if (nextProps === this.props || nextState === this.state) {
            return false;
        }
    }
}

// PureComponent
class Foo extends React.PureComponent {}

// React.memo
function MyComponent(props) {}
export default React.memo(MyComponent, (prevProps, nextProps) => {
    /**
     * Повернення true вказує, що ререндер не потрібен.
     */
    return prevProps.value === nextProps.value;
});
```

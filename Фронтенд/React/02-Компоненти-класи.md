# Компоненти-класи

Працює асинхронно, зміни стану, викликані методом `setState`, застосовуються не миттєво, через особливості того, як працює механізм оновлення DOM у React

-   Використовуються, коли потрібно зберігати стан
-   Класи успадковують `React.Component`
-   Метод `render` повертає елемент (як у функціональному компоненті)
-   `props` доступні через `this.props`

## State (стан)

Внутрішні дані компонента або програми. У React state — стан компонента, що ініціалізується в конструкторі або в тілі класу. Після ініціалізації стан не можна змінювати (тільки читати). Щоб оновити стан, потрібно використовувати метод `setState`, в який потрібно передати об'єкт, якщо стан залежить від попереднього (потрібно змінити значення true на false або потрібно збільшити лічильник), тоді потрібно в `setState` передати функцію аргумент якої буде наш поточний. Стан оновлюється асинхронно. Оновлення стану викликає оновлення компонента та всіх його нащадків (якщо ми будемо прокидати props з App нижче по ієрархії, оновлюватимуться всі дочірні компоненти App)

```js
/**
 * Якщо потрібно встановити стан на основі попереднього
 * стану.
 */
this.setState((state, props) => {
    return { counter: state.counter + props.step };
});
```

## Система подій

-   Будь-який компонент може генерувати власні події (onDone, onAdded)
-   Достатньо передати callback-функцію, як властивість, а потім викликати її з компонента, коли настала подія
-   Через події дані піднімаються «вгору» по ієрархії компонентів

## Життєвий цикл компонентів-класів

-   Компонентам потрібно виконувати код у певні моменти свого життя
-   Наприклад, перед тим, як компонент буде видалено, потрібно очистити ресурси
-   У React для цього є механізм — методи життєвого циклу (lifecycle hooks)

### Mount (монтувати)

1. `constructor` — викликається 1 раз
1. `getDerivedStateFromProps`
1. `render`
1. `componentDidMount` — компонент «підключений» (DOM елементи вже на сторінці), використовується для ініціалізації (отримання даних, роботи з DOM)

В ООП вважається поганою практикою, коли `constructor` має side-ефекти (наприклад починає робити запити до сервера), тому що коли у об'єкта є такий конструктор його складніше тестувати і з ним складніше працювати

До того як React викликає `componentDidMount`, компонент вважається unmounted (перебуває у підвішеному стані, об'єкт вже створений, але він ще не до кінця проініціалізований, у дереві компонентів програми, і до того, як компонент стане mounted, тобто буде викликаний `componentDidMount`, викликати `setState` не можна, такий виклик до `setState` не буде мати ніякого ефекту). Тому ініціалізацію компонентів, які залежать від зовнішніх джерел даних краще проводити в `componentDidMount`

### Update (оновлення)

1. `getDerivedStateFromProps`
1. `shouldComponentUpdate` — метод, який приймає на вхід об'єкт із наступним станом та наступним набором `props`. Component завжди повертає true (викликається `render`, `componentDidUpdate`), PureComponent повертає результат неглибокого порівняння поточного стану props з майбутнім тому, якщо вони не змінилися (принаймні посилання), перемальовки не відбувається
1. `render`
1. `componentDidUpdate(prevProps, prevState)` — викликається після того, як компонент оновився. Компонент оновлюється після отримання нових властивостей або стану. Оскільки цей метод викликається після методу `render`, у ньому можна запитувати нові дані для оновлених властивостей. Якщо в цьому методі може змінитися `state` — обов'язково перевіряти, яка властивість змінилася, інакше компонент піде у «вічний цикл» оновлення

### Unmount (розмонтувати)

1. `componentWillUnmount` — компонент буде видалено, але в момент виклику DOM все ще знаходиться на сторінці. Використовується для очищення ресурсів (таймери, інтервали, запити до сервера)

### Error

1. `getDerivedStateFromError`
1. `componentDidCatch(error, info)` — відловлює помилки, що сталися у методах життєвого циклу нижче за ієрархією. Щоб визначити межі помилок, потрібні компоненти, які розділятимуть незалежні блоки застосуноку. Приймає два аргументи — `error` та `info` з додатковою інформацією про джерело помилок. Не обробляє помилки в event listener та в асинхронному коді (запити до сервера тощо)

## Методи-стрілки та біндінг

Різниця у використанні `this.handlerClick.bind(this)` і `() => this.handlerClick` у тому, що `this.handlerClick.bind(this)`, ми викликаємо в `constructor`, тому функція створюється всього 1 раз, через Reconciliation-алгоритм React, `constructor` буде викликаний всього 1 раз

## shouldComponentUpdate vs PureComponent vs React.memo

```jsx
/**
 * shouldComponentUpdate.
 */
class Foo extends Component {
    shouldComponentUpdate(nextProps, nextState) {
        if (nextProps === this.props || nextState === this.state) return false;
    }
}

/**
 * PureComponent.
 *
 * Тут shouldComponentUpdate реалізований за замовчуванням.
 */
class Foo extends PureComponent {}

/**
 * React.memo.
 */
function MyComponent(props) {}
export default React.memo(MyComponent, (prevProps, nextProps) => {
    /**
     * Якщо поверне true, ререндеру не буде.
     */
    return prevProps.value === nextProps.value;
});
```

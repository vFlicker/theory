# Розрахунок DOM

## `requestAnimationFrame`

При оновленні DOM у циклі використання `requestAnimationFrame` є важливим, оскільки це дозволяє браузеру виконувати свої внутрішні процеси під час роботи JavaScript. Без використання `requestAnimationFrame` сторінка може «зависнути» і не відображати оновлення до тих пір, поки JavaScript не завершить виконання.

Використання `requestAnimationFrame` дозволяє синхронізувати оновлення DOM з оновленням відображення на екрані, забезпечуючи плавну і відзначену з відкликом анімацію або зміни стану.

```js
function updateDOM() {
    // Оновлення DOM
    requestAnimationFrame(updateDOM);
}

requestAnimationFrame(updateDOM);
```

## Розрахунок документа

Розрахунок документа є складним завданням, оскільки браузерні движки оптимізують його виконання, затримуючи перерахунок розкладки, доки це необхідно.

Коли JavaScript змінює документ, браузер не перераховує розкладку негайно. Він очікує до тих пір, поки JavaScript завершить свою роботу, а потім виконує перерахунок розкладки, який включає зміни, внесені JavaScript.

Під час розрахунку розкладки, якщо програма JavaScript запитує позицію або розмір елемента (наприклад, викликає `offsetHeight` або `getBoundingClientRect()`), браузер також повинен зробити розрахунок розкладки для надання коректної інформації.

Якщо програма JavaScript часто змінює DOM та виконує розрахунок розкладки, це може призвести до повільної роботи, оскільки браузеру доводиться часто перераховувати розкладку.

Для досягнення кращої продуктивності рекомендується здійснювати мінімальні зміни DOM та виконувати розрахунок розкладки ефективно. Можна використовувати методи, які змінюють DOM за один раз замість багаторазових додавань або видалень елементів.

Наприклад, замість додавання одного символу X у циклі до того, як ширина досягне 2000px, можна використовувати метод appendChild для додавання групи символів одним разом.

```html
<p><span id="one"></span></p>
<p><span id="two"></span></p>

<script>
    benchmark("bad", () => {
        const target = document.getElementById("one");

        while (target.offsetWidth < 2000) {
            target.appendChild(document.createTextNode("X"));
        }
    }); // Зайняло 32 секунди часу

    benchmark("good", () => {
        const target = document.getElementById("two");

        target.appendChild(document.createTextNode("XXXXX"));

        const total = Math.ceil(2000 / (target.offsetWidth / 5));

        for (let i = 5; i < total; i++) {
            target.appendChild(document.createTextNode("X"));
        }
    }); // Зайняло 1 секунду часу
</script>
```

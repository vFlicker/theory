# Таймери

## Періодичні виклики за допомогою `setInterval`

-   Викликає функцію з заданим інтервалом, повторюючи виклики протягом визначеного проміжку часу.
-   Використання `setInterval` не рекомендується.

## Блокування головного потоку

При використанні `setInterval` може виникнути проблема блокування головного потоку. Коли виконуваний код блокує головний потік на протязі інтервалу, `setInterval` продовжує планувати наступні виклики функції, навіть якщо попередній виклик ще не завершився. Це може призвести до накопичення викликів функції в черзі, особливо при коротких інтервалах.

**Приклад 1**

```js
function foo() {
    /* код, що виконується протягом однієї секунди */
}

setInterval(foo, 100);
```

**Приклад 2**

```jsx
const [seconds, setSeconds] = useState(0);

/* Погано */
useEffect(() => {
    function foo() {
        const timerId = setTimeout(foo, 1000);
        return timerId;
    }

    const interval = setInterval(() => {
        setSeconds((seconds) => seconds + 1);
    }, 1000);
    return () => clearInterval(interval);
}, []);
```

## Використання `setTimeout` для уникнення проблеми блокування

Рекомендованим підходом є використання `setTimeout` замість `setInterval`. В цьому випадку функція викликає сама себе за допомогою `setTimeout` після завершення виконання. Таким чином, ми контролюємо час між викликами і уникнемо накопичення викликів в черзі.

**Приклад 1**

```js
function foo() {
    /* код, що виконується протягом однієї секунди */
    setTimeout(foo, 1000);
}

foo();
```

**Приклад 2**

```jsx
const [seconds, setSeconds] = useState(0);

/* Добре */
useEffect(() => {
    function foo() {
        setSeconds((seconds) => seconds + 1);
        const timerId = setTimeout(foo, 1000);
        return timerId;
    }

    const timerId = foo();
    return () => clearTimeout(timerId);
}, []);
```

Використання `setTimeout` дозволяє точніше контролювати інтервали між викликами функції та уникнути проблеми блокування головного потоку.

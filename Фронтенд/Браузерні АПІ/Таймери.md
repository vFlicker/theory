# Таймери

## Почергові виклики за допомогою `setInterval`

-   Викликає функцію кожні x мілісекунд
-   Використання не рекомендується

## Блокування головного потоку

У той час, коли код, що виконується, буде блокуватися під час виклику з тайм-аутом, `setInterval` продовжуватиме планувати наступні виклики переданої функції. Це може (особливо у разі невеликих інтервалів) спричинити вишукування викликів функцій у чергу.

У нижче наведеному коді `foo` виконається один раз і заблокує головний потік на одну секунду. Поки `foo` блокує код, setInterval продовжує планувати її подальші виклики. Тепер, коли перша `foo` закінчила виконання, у черзі будуть уже десять чекаючих викликів `foo`.

```js
function foo() {
    /* щось, що виконується одну секунду */
}

setInterval(foo, 100);
```

Найпростіший і найконтрольованіший спосіб — використовувати setTimeout всередині самої функції

```js
function foo() {
    /* щось, що виконується одну секунду */
    setTimeout(foo, 100);
}

foo();
```

```jsx
const [seconds, setSeconds] = useState(0);

/* Bad */
// useEffect(() => {
//     function foo() {
//         const timerId = setTimeout(foo, 1000);
//         return timerId;
//     }

//     const interval = setInterval(() => {
//         setSeconds((seconds) => seconds + 1);
//     }, 1000);
//     return () => clearInterval(interval);
// }, []);

/* Good */
useEffect(() => {
    function foo() {
        setSeconds((seconds) => seconds + 1);
        const timerId = setTimeout(foo, 1000);
        return timerId;
    }

    const timerId = foo();
    return () => clearTimeout(timerId);
}, []);
```

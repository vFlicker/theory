# Proxy and Reflect

## Proxy

Обгортка навколо об'єкта, яка «за замовчуванням» перенаправляє операції над нею на об'єкт, але може перехоплювати їх. Проксіювати можна будь-який об'єкт, включаючи класи та функції

### Ми можемо перехоплювати

-   Читання (get), запис (set), видалення (deleteProperty) властивості
-   Виклик функції (apply)
-   Оператор new (пастка construct)
-   Багато інших операцій

### Може реалізувати

-   Паттерн Адаптер
-   Кешування
-   Екранування
-   Підрахунок викликів
-   Створення обгорток

## Reflect

Вбудований об'єкт, який спрощує створення проксі

-   Єдиний простір назв для роботи з метаданими
-   Збирає старі можливості
-   Додає нові можливості

**Приклад 1**

```js
const person = {
    name: "John Doe",
    age: 42,
    nationality: "American",
};

const personProxy = new Proxy(person, {
    get: (obj, prop) => {
        if (!obj[prop]) {
            console.log(`Hmm.. this property doesn't seem to exist`);
        } else {
            // console.log(`The value of ${prop} is ${obj[prop]}`);
            console.log(`The value of ${prop} is ${Reflect.get(obj, prop)}`);
        }
    },
    set: (obj, prop, value) => {
        if (prop === "age" && typeof value !== "number") {
            console.log(`Sorry, you can only pass numeric values for age.`);
        } else if (prop === "name" && value.length < 2) {
            console.log(`You need to provide a valid name.`);
        } else {
            // console.log(`Changed ${prop} from ${obj[prop]} to ${value}.`);
            // obj[prop] = value;
            console.log(`Changed ${prop} from ${Reflect.get(obj, prop)} to ${value}`);
            return Reflect.set(obj, prop, value);
        }
        // return true;
    },
});

personProxy.nonExistentProperty;
personProxy.name;
personProxy.age = 43;
```

**Приклад 2**

```js
/** Обгортка над об'єктом, `withDefaultValue`,
 * якщо в об'єкті не буде потрібного ключа, ми повернемо
 * значення «за замовчуванням»
 */
const withDefaultValue = (target, defaultValue = 0) => {
    return new Proxy(target, {
        get: (obj, prop) => (prop in obj ? Reflect.get(obj, prop) : defaultValue),
    });
};
```

**Приклад 3**

```js
/** Обгортку над об'єктом, withoutHiddenProps,
 * якщо в об'єкті ім'я ключа буде починатися з `_`,
 * ми не будемо його показувати
 */
const withHiddenProps = (target, prefix = `_`) => {
    return new Proxy(target, {
        has: (obj, prop) => {
            return prop in obj && !prop.startsWith(prefix);
        },
        ownKeys: (obj) => {
            return Reflect.ownKeys(obj).filter(
                (item) => !item.startsWith(prefix)
            );
        },
        get: (obj, prop, receiver) => {
            return prop in receiver ? Reflect.get(obj, prop) : undefined;
        },
    });
};
```

**Приклад 4**

```js
/** Можна зробити індекс для масиву, для більш швидкого
 * пошуку id в масиві об'єктів
 */
const IndexedArray = new Proxy(Array, {
    construct(target, [args]) {
        const index = {};

        for (arg of args) index[arg.id] = arg;

        return new Proxy(new target(...args), {
            get(arr, prop) {
                switch (prop) {
                    case "push":
                        return (item) => {
                            index[item.id] = item;
                            arr[prop].call(arr, item);
                        };
                    case "findById":
                        return (id) => index[id];
                    default:
                        return arr[prop];
                }
            },
        });
    },
});

const users = new IndexedArray([
    { id: 11, name: "Vladilen", job: "Fullstack", age: 25 },
    { id: 22, name: "Elena", job: "Student", age: 22 },
    { id: 33, name: "Victor", job: "Backend", age: 23 },
    { id: 44, name: "Vasilisa", job: "Teacher", age: 24 },
]);
```

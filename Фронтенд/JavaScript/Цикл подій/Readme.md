# Event loop (цикл подій)

Цикл подій в JavaScript вирішує одну основну задачу — спостерігає за стеком викликів та чергою колбеків:

1. Якщо стек викликів порожній, цикл бере першу подію з черги та поміщає її у стек, що призводить до запуску відповідного колбеку для виконання
2. Цей процес називається ітерацією циклу подій
3. Кожна подія в циклі подій є колбеком, який очікує виконання

## Стеком викликів

Під час виконання JavaScript коду, інтерпретатор користується стеком викликів, який є прихованим для нас. У ньому зберігається інформація про поточні виклики функцій.

Розглянемо приклад:

```js
const question = () => {
    const answer = prompt("Some question...");
    check(answer);
};

const check = (answer) => {
    alert(answer === "Деяке питання..." ? "Так" : "Ні");
};

question();
```

1. Коли викликається функція `question`, движок JavaScript створює контекст виконання цієї функції та додає його до стеку викликів, щоб не забути про виконання цієї функції.

```js
question();
```

2. Виклик функції `question` призводить до зустрічі з функцією `prompt`. Інтерпретатор розуміє, що потрібно призупинити виконання поточної функції, викликати `prompt` та виконати його.

3. Функція `prompt` та переданий аргумент поміщаються в стек викликів:

```js
prompt('Деякий текст...');
question();
```

4. Після повного виконання функції `prompt`, інтерпретатор видаляє її зі стеку викликів та продовжує виконання функції `question`. Для цього він переглядає вершину стеку викликів та знаходить потрібну точку відновлення виконання (інформація про те, в якому місці функції знаходиться інтерпретатор, теж зберігається в стеку):

```js
question();
```

5. Після продовження виконання функції `question`, ми увійдемо в функцію `check`, а потім в функцію `alert`:

```js
alert(true/false);
check("Деяка відповідь...");
question();
```

Отже, стек викликів — це механізм зберігання інформації про виклики функцій, що дозволяє повернутися до «батьківської» функції після завершення виконання поточної функції. Він також зберігає локальні змінні та аргументи функцій.

### Переповнення стеку

Стек викликів — це виділена пам'ять, яка може закінчуватися, і на певному етапі може не бути достатньо місця для зберігання інформації про нові виклики. Це становить ризик переповнення стеку. У такому випадку, інтерпретатор відмовляється працювати в таких умовах і викидає виняток.

Прикладом ситуації переповнення стеку може бути обчислення числа Фібоначчі для дуже великого індексу, наприклад, 1000. У цьому випадку, кількість об'єктів, що описують стан виконання, які були б додані в стек, може перевищити його межі.

## Macrotasks (макрозадачі)

Macrotasks — це великі задачі або події, які потрапляють в чергу подій і виконуються після виконання поточної задачі. Деякі приклади макрозадач включають:

-   Завантаження скриптів
-   Події браузера (натискання, переміщення миші, виклик таймерів тощо)
-   Рендеринг

Після виконання кожної макрозадачі, движок виконує всі мікрозадачі з черги перед тим, як перейти до наступної макрозадачі або відобразити зміни на сторінці.

## Microtasks (мікрозадачі)

Microtasks — це менші задачі, які також потрапляють в чергу подій, але виконуються після виконання поточної мікрозадачі. Основний приклад мікрозадач — обробка промісів (Promise).

Коли проміс виконується, його обробники then/catch/finally додаються до черги мікрозадач. Вони не виконуються відразу, але очікують своєї черги. Движок JavaScript (наприклад, V8) бере мікрозадачу з черги та виконує її після того, як він звільниться від виконання поточного коду.

## Алгоритм роботи Event loop

Алгоритм роботи Event loop можна описати таким чином:

1. Вибрати і виконати найстарішу макрозадачу з черги макрозадач
2. Виконувати всі мікрозадачі з черги мікрозадач (вибирати і виконувати найстарішу мікрозадачу, поки черга мікрозадач не порожня)
3. Відобразити зміни на сторінці, якщо такі є
4. Якщо черга макрозадач порожня, зачекати на появу нової макрозадачі
5. Повернутися до кроку 1



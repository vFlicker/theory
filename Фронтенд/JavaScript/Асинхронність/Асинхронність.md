# Асинхронність

Виконання операції без блокування основного процесу програми

## Обробка через колбеки

-   Складний інтерфейс — потрібно перерахувати всі можливі колбеки, складно зробити опціональну обробку деяких ситуацій
-   Складне читання коду — відтворити послідовність методів є нетривіальним завданням
-   Пекло із коллбеків — кілька послідовних асинхронних дій перетворюються на вкладення послідовності колбеків, які складно підтримують

## Promise (обіцянка)

Використовується для відкладених та асинхронних обчислень. Повертає об'єкт, що заміщає повертаєме-значення, яке на момент завершення функції ще не відомо. Обробка може проводитися ланцюжками методів. Будь-який виклик `then` повертає Promise, у якого також можна викликати `then`. Може знаходитись у одному з трьох станів

-   pending (очікування) — початковий стан (не виконаний і не відхилений)
-   fulfilled (виконано) — операція завершена успішно
-   rejected (відхилено) — операцію завершено з помилкою

## async/await

Конструкції мови (являє собою додатковий рівень абстракції для генераторів) для роботи з `Promise`, мета якого спростити використання `Promise`, що дозволяють привести асинхронний код для синхронного вигляду. **Важливо**, що це лише представлення коду, сам код залишається асинхронним за своєю природою

### async

-   Ключове слово для функції чи методу
-   Функція, позначена як async, завжди повертає `Promise`
-   Коли результат був отриманий, `Promise` завершується, повертаючи отримане значення.
-   Коли функція кидає виняток, `Promise` відповість відмовою з викинутим значенням
-   Async функцію ніколи не має сенсу викликати всередині `try_catch` блоку

### await

-   Ключове слово, доступне всередині async-функції
-   Зупиняє виконання функції і чекає відповіді від переданого `Promise`
-   Якщо в результаті `await` роботи `Promise` викинув виняток, то його можна обробити за допомогою блоку `try_catch`
-   Ключове слово `await` допустиме лише в асинхронних функціях, в іншому контексті ви отримаєте помилку `SyntaxError`

### Особливості

-   Будь-яка функція, яка повертає `Promise` працює так само, як async-функція
-   Під час виклику async-функції завжди потрібно стежити за тим, щоб оброблявся результат `Promise`
-   `await` ніколи не замикається - не може бути вкладений в іншу функцію
-   Конструктори не можуть бути асинхронними
-   Гетери та сетери не можуть бути асинхронними

```js
/*
    Якщо використовувати await біля функцій resolveAfter2Seconds,
    виконання методу sum займе ~4 секунди
*/
const sum = async (x) => {
    const a = resolveAfter2Seconds(1);
    const b = resolveAfter2Seconds(2);
    return x + (await a) + (await b);
};
```

```js
/*
    Якщо не перевіряти initialized, є ймовірність,
    що відбудеться створення нового інстансу
*/
class Singleton {
    constructor() {
        this.order = order++;
        console.log("I'm the first one");
    }

    static async init() {
        await resolveAfter2Seconds(); // simulate async loading
        return new Singleton();
    }
}

let instance;

const getInstance = async () => {
    if (instance) return instance;

    const initialized = await Singleton.init();
    if (!initialized) instance = initialized;

    return instance;
};

getInstance().then((i) => console.log(i.order));
getInstance().then((i) => console.log(i.order));
getInstance().then((i) => console.log(i.order));
```

```js
/*
    Виконання такого коду займе ~20 секунд
*/
const iterate = async (num) => {
    let sum = 0;
    for (let i = 0; i < 10>; i++) {
        sum += await resolveAfter2Seconds(10);
    }
    return sum;
};
```

## Література

<a href="https://habr.com/ru/company/mailru/blog/269465">У нас проблеми із промісами</a>

# Quicksort (швидке сортування)

**Приклад 1**

Складність алгоритму за часом — O(n log n)
Складність алгоритму за пам'яттю — O(n)

```js
let iterationsNumber = 0;

const quickSort = (array) => {
    // умова виходу з рекурсії
    // якщо переданий масив має менше двох елементів — нема що сортувати
    if (array.length < 2) return array;

    // знаходимо опорний індекс поділом на два і округленням вниз
    const pivotIndex = Math.floor(array.length / 2);
    const pivot = array[pivotIndex];
    const min = [];
    const max = [];

    for (let index = 0; index < array.length; index++) {
        iterationsNumber += 1;

        // якщо індекс дорівнює опорному елементу, йдемо на наступну ітерацію
        if (index === pivotIndex) continue;

        // знаходимо поточний елемент
        const current = array[index];

        // якщо поточний елемент менше опорного
        if (current < pivot) {
            min.push(current); // додаємо його в масив min
        } else {
            // інакше поточний елемент більше опорного
            max.push(current); // додаємо його в масив max
        }
    }

    return [...quickSort(min), pivot, ...quickSort(max)];
};

const array = [3, 10, 1, 4, 2, 7, 5, 8, 9, 6];
console.log(quickSort(array));
console.log(`Number of iterations: ${iterationsNumber}`);
```

**Приклад 2**

Складність алгоритму за часом — O(n log n)
Складність алгоритму за пам'яттю — O(log n)

```js
const random = (min, max) => {
    // Інтервал, в якому можуть бути наші числа
    const interval = max - min;

    // Пошук випадкового числа починатиметься не з нуля, а з min
    const shift = min;

    return Math.round(Math.random() * interval + shift);
};

// Так як у підрозбиттях після рекурсивного виклику сортування
// ми будемо працювати не з цілим масивом а його частинами,
// відразу зробимо додаткові параметри для їх визначення
const partition = (array, left, right) => {
    // Знаходимо значення, навколо якого розміщуватимемо елементи
    const pivot = array[random(left, right)];

    // будемо сходитися з країв у центр, доки не переглянемо
    // всі елементи
    while (left < right) {
        // Поки що зліва зустрічаються лише числа менше поворотного
        while (array[left] < pivot) {
            // рухаємо лівий покажчик праворуч,
            // адже з цими числами нічого робити не треба
            left++;
        }

        // Поки що справа зустрічаються тільки числа більше поворотного
        while (array[right] > pivot) {
            // рухаємо правий покажчик вліво,
            // адже з цими числами нічого робити не треба
            right--;
        }

        // Як тільки обидва вказівники вказують на елементи,
        // які мають бути в протилежних частинах,
        // і ми все ще не зійшлися до центру
        if (left <= right) {
            // міняємо їх місцями і не забуваємо рухати обидва вказівники,
            // тому що тепер обидва числа на своєму місці
            [array[left], array[right]] = [array[right], array[left]];
            left++;
            right--;
        }
    }

    // Повертаємо місце, де виявився елемент,
    // що дорівнює нашій точці повороту
    return left;
};

const quickSort = (array, left = 0, right = array.length - 1) => {
    const pivotIndex = partition(array, left, right);

    if (left < pivotIndex - 1) {
        quickSort(array, left, pivotIndex - 1);
    }

    if (pivotIndex < right) {
        quickSort(array, pivotIndex, right);
    }

    return array;
};

const array = [3, 10, 1, 4, 2, 7, 5, 8, 9, 6];
console.log(quickSort(array));
```

**Приклад 3**

Складність алгоритму за часом — O(n log n)
Складність алгоритму за пам'яттю — O(log n)

```js
const random = (min, max) => {
    // Інтервал, в якому можуть бути наші числа
    const interval = max - min;

    // Пошук випадкового числа починатиметься не з нуля, а з min
    const shift = min;

    return Math.round(Math.random() * interval + shift);
};

// Так як у підрозбиттях після рекурсивного виклику сортування
// ми будемо працювати не з цілим масивом а його частинами,
// відразу зробимо додаткові параметри для їх визначення
const partition = (array, left, right) => {
    // Знаходимо значення, навколо якого розміщуватимемо елементи
    const { leaguePoints: pivot } = array[random(left, right)];

    // будемо сходитися з країв у центр, доки не переглянемо
    // всі елементи
    while (left < right) {
        // Поки зліва зустрічаються лише числа менше поворотного
        while (array[left].leaguePoints < pivot) {
            // рухаємо лівий покажчик праворуч,
            // адже з цими числами нічого робити не треба
            left++;
        }

        // Поки справа зустрічаються тільки числа більше поворотного
        while (array[right].leaguePoints > pivot) {
            // рухаємо правий покажчик вліво,
            // адже з цими числами нічого робити не треба
            right--;
        }

        // Як тільки обидва вказівники вказують на елементи,
        // які мають бути в протилежних частинах,
        // і ми все ще не зійшлися до центру
        if (left <= right) {
            // міняємо їх місцями і не забуваємо рухати обидва вказівники,
            // тому що тепер обидва числа на своєму місці
            [array[left], array[right]] = [array[right], array[left]];
            left++;
            right--;
        }
    }

    // Повертаємо місце, де виявився елемент,
    // що дорівнює нашій точці повороту
    return left;
};

// Просте сортування, яке може працювати тільки з масивами з трьох
// і менш елементів, яка через ліміт на вхідні дані працює за O(1)
const sortThree = (array) => {
    // Якщо масив порожній, його і повернемо
    if (!array.length) {
        return array;
    }

    // Інакше покладемо перший елемент у відсортований масив
    const sorted = [array[0]];

    // Якщо у масиві є друге число, то вставимо його у потрібне місце
    // у нашому відсортованому
    if (array[1]) {
        if (array[1].leaguePoints > array[0].leaguePoints) {
            sorted.push(array[1]);
        } else {
            sorted.unshift(array[1]);
        }
    }

    // Якщо масиві є і третє число, то також вставимо і його
    if (array[2]) {
        // Або на початок, якщо він менший за початок відсортованого масиву
        if (array[2].leaguePoints < sorted[0].leaguePoints) {
            sorted.unshift(array[2]);
            // Або в кінці, якщо він більше початку відсортованого масиву
        } else if (array[2].leaguePoints > sorted[1].leaguePoints) {
            sorted.push(array[2]);
            // Або в середину в іншому випадку
        } else {
            sorted.splice(1, 0, array[2]);
        }
    }

    return sorted.reverse();
};

const topThree = (data) => {
    if (data.length <= 3) {
        return sortThree(data);
    }

    // Ми дуже хочемо, щоб наша точка повороту виявилася
    // рівно на початку трійці, яку нам потрібно повернути,
    // щоб не сортувати зайвих підмасивів
    const desiredPivot = data.length - 3;

    // Будемо зберігати останню точку повороту, яку нам дав поділ
    let pivot = partition(data, 0, data.length - 1);

    // Ще збережемо мінімальну точку повороту, починаючи з якої
    // нам буде нецікаво, що відбувається ліворуч — нам все-таки треба
    // відсортувати лише праву частину масиву. При тому,
    // якщо ми відразу перескочили потрібну нам точку повороту,
    // то нам таки доведеться подивитися на ліві елементи.
    let minimalPivot = pivot > desiredPivot ? 0 : pivot;

    // Поки точка повороту не в тому місці, яке нам необхідно,
    // намагаємось зрушити її туди.
    while (pivot !== desiredPivot) {
        // Якщо ми правіше, ніж потрібно, значить треба зрушити ліворуч
        if (pivot > desiredPivot) {
            // Ми знаємо, з якого елемента нам сортування нецікаве,
            // тому там сортувати і не будемо
            pivot = partition(data, minimalPivot, pivot);
            // А інакше рухаємося вправо
        } else {
            pivot = partition(data, minimalPivot, data.length - 1);
        }

        // Обновимо мінімально цікавий нам підмасив
        // за аналогією з його ініціалізацією
        minimalPivot = pivot > desiredPivot ? minimalPivot : pivot;
    }

    return sortThree(data.slice(-3));
};

const data = [
    {
        login: "DreamLess",
        leaguePoints: 956,
    },
    {
        login: "cavernous",
        leaguePoints: 1056,
    },
    {
        login: "SaiyanBroadway",
        leaguePoints: 1432,
    },
    {
        login: "BlondiePlanet",
        leaguePoints: 1045,
    },
    {
        login: "Mountaintrid",
        leaguePoints: 1130,
    },
    {
        login: "cathead",
        leaguePoints: 930,
    },
    {
        login: "rstrazir",
        leaguePoints: 356,
    },
    {
        login: "stypeano",
        leaguePoints: 4,
    },
    {
        login: "CzarStories",
        leaguePoints: 568,
    },
    {
        login: "ConspiracyLil",
        leaguePoints: 18,
    },
    {
        login: "GottaSaiyan",
        leaguePoints: 931,
    },
    {
        login: "Goldenelox",
        leaguePoints: 932,
    },
    {
        login: "Breakingbing",
        leaguePoints: 64,
    },
    {
        login: "Rectionom",
        leaguePoints: 42,
    },
    {
        login: "BoostScooby",
        leaguePoints: 1476,
    },
    {
        login: "JoshChase",
        leaguePoints: 931,
    },
];
console.log(topThree(data, 3)); // 1476, 1432, 1130
```

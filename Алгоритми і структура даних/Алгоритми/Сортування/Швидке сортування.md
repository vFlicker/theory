# Quicksort (швидке сортування)

Складність алгоритму за часом — O(n log n)
Складність алгоритму за пам'яттю — O(log n)

```js
const array = [3, 10, 1, 4, 2, 7, 5, 8, 9, 6];
let iterationsNumber = 0;

const quickSort = (array) => {
    // умова виходу з рекурсії
    // якщо переданий масив має менше двох елементів — нема що сортувати
    if (array.length < 2) return array;

    // знаходимо опорний індекс поділом на два і округленням вниз
    const pivotIndex = Math.floor(array.length / 2);
    const pivot = array[pivotIndex];
    const min = [];
    const max = [];

    for (let index = 0; index < array.length; index++) {
        iterationsNumber += 1;

        // якщо індекс дорівнює опорному елементу, йдемо на наступну ітерацію
        if (index === pivotIndex) continue;

        // знаходимо поточний елемент
        const current = array[index];

        // якщо поточний елемент менше опорного
        if (current < pivot) {
            min.push(current); // додаємо його в масив min
        } else {
            // інакше поточний елемент більше опорного
            max.push(current); // додаємо його в масив max
        }
    }

    return [...quickSort(min), pivot, ...quickSort(max)];
};

console.log(quickSort(array));
console.log(`Number of iterations: ${iterationsNumber}`);
```

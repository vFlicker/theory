# Quicksort (швидке сортування)

**Приклад 1**

Складність алгоритму за часом — O(n log n)
Складність алгоритму за пам'яттю — O(n)

```js
let iterationsNumber = 0;

const quickSort = (array) => {
    // умова виходу з рекурсії
    // якщо переданий масив має менше двох елементів — нема що сортувати
    if (array.length < 2) return array;

    // знаходимо опорний індекс поділом на два і округленням вниз
    const pivotIndex = Math.floor(array.length / 2);
    const pivot = array[pivotIndex];
    const min = [];
    const max = [];

    for (let index = 0; index < array.length; index++) {
        iterationsNumber += 1;

        // якщо індекс дорівнює опорному елементу, йдемо на наступну ітерацію
        if (index === pivotIndex) continue;

        // знаходимо поточний елемент
        const current = array[index];

        // якщо поточний елемент менше опорного
        if (current < pivot) {
            min.push(current); // додаємо його в масив min
        } else {
            // інакше поточний елемент більше опорного
            max.push(current); // додаємо його в масив max
        }
    }

    return [...quickSort(min), pivot, ...quickSort(max)];
};

const array = [3, 10, 1, 4, 2, 7, 5, 8, 9, 6];
console.log(quickSort(array));
console.log(`Number of iterations: ${iterationsNumber}`);
```

**Приклад 2**

Складність алгоритму за часом — O(n log n)
Складність алгоритму за пам'яттю — O(log n)

```js
const random = (min, max) => {
    // Інтервал, в якому можуть бути наші числа
    const interval = max - min;

    // Пошук випадкового числа починатиметься не з нуля, а з min
    const shift = min;

    return Math.round(Math.random() * interval + shift);
};

// Так як у підрозбиттях після рекурсивного виклику сортування
// ми будемо працювати не з цілим масивом а його частинами,
// відразу зробимо додаткові параметри для їх визначення
const partition = (array, left, right) => {
    // Знаходимо значення, навколо якого розміщуватимемо елементи
    const pivot = array[random(left, right)];

    // будемо сходитися з країв у центр, доки не переглянемо
    // всі елементи
    while (left < right) {
        // Поки що зліва зустрічаються лише числа менше поворотного
        while (array[left] < pivot) {
            // рухаємо лівий покажчик праворуч,
            // адже з цими числами нічого робити не треба
            left++;
        }

        // Поки що справа зустрічаються тільки числа більше поворотного
        while (array[right] > pivot) {
            // рухаємо правий покажчик вліво,
            // адже з цими числами нічого робити не треба
            right--;
        }

        // Як тільки обидва вказівники вказують на елементи,
        // які мають бути в протилежних частинах,
        // і ми все ще не зійшлися до центру
        if (left <= right) {
            // міняємо їх місцями і не забуваємо рухати обидва вказівники,
            // тому що тепер обидва числа на своєму місці
            [array[left], array[right]] = [array[right], array[left]];
            left++;
            right--;
        }
    }

    // Повертаємо місце, де виявився елемент,
    // що дорівнює нашій точці повороту
    return left;
};

const quickSort = (array, left = 0, right = array.length - 1) => {
    const pivotIndex = partition(array, left, right);

    if (left < pivotIndex - 1) {
        quickSort(array, left, pivotIndex - 1);
    }

    if (pivotIndex < right) {
        quickSort(array, pivotIndex, right);
    }

    return array;
};

const array = [3, 10, 1, 4, 2, 7, 5, 8, 9, 6];
console.log(quickSort(array));
```

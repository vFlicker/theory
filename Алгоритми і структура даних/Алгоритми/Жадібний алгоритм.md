# Жадібний алгоритм (Greedy Algorithm)

Жадібний алгоритм — це підхід до розв'язання задач, де на кожному кроці обирається локально оптимальний варіант з метою досягнення глобально оптимального результату. Цей метод використовується для знаходження найкращого рішення на кожному етапі, враховуючи поточний стан задачі.

Принцип жадібного алгоритму можна описати так: «Обирайте найкращий варіант, доступний зараз, і не враховуйте майбутні наслідки». Тобто, алгоритм зосереджується на миттєвому оптимальному рішенні, не дбаючи про його можливі впливи на майбутні етапи.

Проте варто зазначити, що жадібні алгоритми не завжди гарантують знаходження глобально оптимального розв'язку, оскільки їх вибір може бути обмеженим. Є ситуації, де жадібний підхід може привести до під-оптимальних або навіть некоректних результатів.

## Приклад: Вибір найменшої кількості монет

Для ілюстрації жадібного алгоритму можна розглянути задачу вибору найменшої кількості монет для видавання певної суми решти. Нехай маємо монети номіналами 1, 5, 10 і 25 копійок, а ми повинні видати решту 43 копійки. Жадібний алгоритм спробує вибрати якомога більше монет більшого номіналу, щоб зменшити кількість монет загалом. У цьому випадку, алгоритм може обрати 25, 10, 5, 1 копійки, загалом 4 монети.

В даному випадку жадібний алгоритм приведе до оптимального розв'язку. Однак у загальному випадку жадібний підхід може не завжди привести до найкращих результатів. Наприклад, якщо у нас є монети 1, 3 і 4 копійки, а ми повинні видати решту 6 копійок, жадібний алгоритм вибере 4 і 1 копійку, загалом 2 монети, тоді як оптимальним розв'язком буде використання трьох монет по 3 копійки.

## Приклад: Знаходження найкоротшого шляху в графі

Ще одним прикладом використання жадібного алгоритму є задача знаходження найкоротшого шляху в зваженому графі з невід'ємними вагами. **Алгоритм Дейкстри** — це приклад жадібного алгоритму, який знаходить найкоротший шлях між початковим і кінцевим вузлами.

В основі алгоритму Дейкстри лежить ідея вибору найкоротшого доступного шляху на кожному кроці. Алгоритм починає з початкового вузла і розглядає всі його сусіди. Він вибирає найкоротший шлях до сусіда і додає його до списку можливих шляхів. Потім алгоритм переходить до сусіда з найкоротшим шляхом та продовжує цей процес доки не буде досягнуто кінцевого вузла.

Алгоритм Дейкстри гарантує знаходження найкоротшого шляху в графі з невід'ємними вагами. Однак у графах з негативними вагами він може не працювати коректно.

### Розв'язання задачі

Припустимо, ми маємо граф з вагованими ребрами та нам потрібно знайти найкоротший шлях від вершини `A` до `F`.

```
       A
    /  |  \
   8   12   4
  /     |     \
 B--5--C--2----D
  \     |      |
   3    |      |
    \   |     /
     E   6   15
      \  |  /
       4 | /
        \|/
         F
```

1. Починаємо з початкового вузла `A` і присвоюємо йому відстань `0`, а всім іншим вузлам — нескінченність.
2. Розглядаємо всіх сусідів `A` (`B`, `C`, `D`) і оновлюємо їх відстані, якщо знайдено коротший шлях. Відстань до `B` стає `8`, до `C` — `12`, до `D` — `4`.
3. Обираємо вузол з найменшою відстанню, який ще не був відвіданий. У цьому випадку, обираємо `D`.
    1. Розглядаємо всіх сусідів `D` (`A`, `C`, `F`) і оновлюємо їх відстані, якщо знайдено коротший шлях. Відстань до `C` стає `6`, до `F` — `15`.
4. Обираємо наступний вузол з найменшою відстанню, який ще не був відвіданий. У цьому випадку, обираємо `B`.
    1. Розглядаємо всіх сусідів `B` (`A`, `C`, `E`) і оновлюємо їх відстані, якщо знайдено коротший шлях. Відстань до `E` стає `11`.
5. Продовжуємо обирати вузли з найменшою відстанню і оновлювати відстані їх сусідів до тих пір, поки не відвідаємо кінцевий вузол `F`.
6. Після відвідування `F` ми завершуємо алгоритм. Найкоротший шлях від `A` до `F` складає `12`. Оптимальний маршрут буде: `A` -> `C` -> `D` -> `F`.

# Binary Search (бінарний пошук)

Бінарний пошук — це ефективний алгоритм пошуку елемента в відсортованому масиві шляхом поділу діапазону пошуку навпіл на кожній ітерації.

Алгоритм працює наступним чином:

1. Встановити початкові значення лівої та правої межі пошуку: `leftIndex = 0` і `rightIndex = arr.length - 1`.
2. Поки `leftIndex` менше або дорівнює `rightIndex`, повторювати:
    - Обчислити середній індекс між `leftIndex` і `rightIndex`: `mid = Math.floor((leftIndex + rightIndex) / 2)`.
    - Порівняти значення елемента `middleValue` з шуканим елементом `item`:
        - Якщо `middleValue` дорівнює `item`, повернути `item`.
        - Якщо `middleValue` більше `item`, оновити `rightIndex = middleIndex - 1;`.
        - Якщо `middleValue` менше `item`, оновити `leftIndex = middleIndex + 1`
3. Якщо не знайдено збіг, повернути спеціальне значення, що вказує на те, що елемент не знайдено.

Складність алгоритму за часом — `O(log n)`
Складність алгоритму за пам'яттю — `O(1)`

**Приклад 1 (ітеративний)**

```js
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let iterationsNumber = 0;

const binarySearch = (array, item) => {
    let leftIndex = 0;
    let rightIndex = array.length - 1;

    while (leftIndex <= rightIndex) {
        iterationsNumber += 1;

        const middleIndex = Math.floor((leftIndex + rightIndex) / 2);
        const middleValue = array[middleIndex];

        if (middleValue === item) return middleValue;

        if (middleValue > item) {
            rightIndex = middleIndex - 1;
        } else {
            leftIndex = middleIndex + 1;
        }
    }

    return -1;
};

console.log(binarySearch(array, 5));
console.log(`Number of iterations: ${iterationsNumber}`);
```

**Приклад 2 (ітеративний)**

```js
const binarySearch = (plants, plant) => {
    let leftIndex = 0;
    let rightIndex = plants.length - 1;

    while (leftIndex <= rightIndex) {
        const middleIndex = Math.floor((leftIndex + rightIndex) / 2);
        const middleValue = plants[middleIndex];

        if (middleValue === plant) return middleValue;

        if (middleValue.localeCompare(plant) === 1) {
            rightIndex = middleIndex - 1;
        } else {
            leftIndex = middleIndex + 1;
        }
    }

    return null;
};

const plants = [
    "Asparagus",
    "Carnation",
    "Jasmine",
    "Guelder Rose",
    "Raspberry",
    "Peony",
    "Yarrow",
    "Chrysanthemum",
    "Saffron",
    "Yucca",
];

console.log(binarySearch(plants, "Peony")); // 5
console.log(binarySearch(plants, "Rose")); // null
```

**Приклад 3 (рекурсивний)**

```js
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let iterationsNumber = 0;

const binarySearch = (array, item) => {
    iterationsNumber += 1;

    const start = 0;
    const end = array.length - 1;
    const middle = Math.floor((start + end) / 2);
    const currentItem = array[middle];

    if (start > end) return;

    if (item === currentItem) return item;

    if (item > currentItem) {
        return binarySearch(array.slice(middle + 1), item);
    } else {
        return binarySearch(array.slice(start, middle), item);
    }
};

console.log(binarySearch(array, 5));
console.log(`Number of iterations: ${iterationsNumber}`);
```

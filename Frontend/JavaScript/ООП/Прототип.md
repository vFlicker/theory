## Prototype

Prototype (прототип) — механізм, за допомогою якого об'єкти в JavaScript успадковують властивості один від одного. Властивості та методи, що визначаються прототипом, є функції-конструктора, а не самих об'єктів. Значення властивості `prototype` — об'єкт, який в основному являє собою контейнер для зберігання властивостей та методів, які ми хочемо успадкувати об'єктами, розташованими далі по ланцюжку прототипів

### Як відбувається успадкування

```js
function Person(name, age) {
    this.name = name;
    this.age = age;
}

const bob = new Person("Bob", 32);
bob.valueOf(); // Person { name: 'Bob', age: 32 }
```

`Object.valueOf()` — успадковується bob, тому що його конструктором є `Person()`, а прототипом `Person()` є `Object()`

-   Спочатку браузер перевіряє, чи має об'єкт bob доступний у ньому метод `valueOf()`, як визначено у його конструкторі `Person()`
-   Наступним кроком браузер перевіряє, чи має прототип об'єкта `Object()` конструктора `Person()` доступний у ньому метод `valueOf()`

### Успадкування

Успадкування реалізується через приховане посилання властивості `__proto__`. `__proto__` — це посилання інстанса класу на `prototype` батьківського класу інстанса. Екземпляр має властивість `__proto__` це посилання на prototype-об'єкт батька.

Якщо в об'єкті немає якоїсь властивості, то воно за посиланням `__proto__` шукається у прототипі цього
об'єкт

### Успадкування `Object.create`

`Object.create` — це простий спосіб дозволити об'єктам безпосередньо успадковувати властивості від інших об'єктів, вказавши прототип новоствореного об'єкта. Новий об'єкт може отримати доступ до нових властивостей, пройшовши по ланцюжку прототипів

```js
function Pet(name) {
    this.name = name;
}

Pet.prototype.eat = function (food) {
    console.log(`I'm eating ${food}`);
};

function Dog(name) {
    Pet.call(this, name);
}

/**
 * `Object.create` створює новий об'єкт, використовуючи
 * наявний об'єкт як прототип новоствореного об'єкта
 *
 * Так додаткові методи і властивості записуються
 * в prototype Dog
 * Teacher.prototype = Person.prototype;
 */
Dog.prototype = Object.create(Pet.prototype);

/**
 * Гарний спосіб перевизначити назву `constructor`,
 * так його не буде видно при використанні `for..in`,
 * на відміну від такого перезапису
 *
 * Dog.prototype.constructor = Dog;
 */
Object.defineProperty(Dog.prototype, "constructor", {
    value: Dog,
    // Якщо `enumerable: false`, дану властивість
    // не буде видно у циклі `for..in`
    enumerable: false,
    writable: true,
});
```

### prototype функції-конструктор

Кожна функція-конструктор має властивість `prototype`, значенням якого є об'єкт, що містить властивість конструктора. Ця властивість конструктор вказує на вихідну функцію-конструктор

### Продуктивність та 'hasOwnProperty'

`hasOwnProperty` - єдина існуюча в JavaScript можливість працювати з властивостями, не торкаючись ланцюжка прототипів. Якщо вам необхідно перевірити, чи визначено властивість самого об'єкта, а не десь у його ланцюжку, прототипів, можна використовувати метод `hasOwnProperty`, який всі об'єкти успадковують від `Object.prototype`

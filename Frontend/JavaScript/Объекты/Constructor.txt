https://habr.com/ru/post/151070/
В Javascript конструктор является обычной функцией и поэтому определяется так:

var Cat = function(name) {
  this.name = name;
  this.say = function() {
    return "I am" + this.name;
  }
}

При вызове конструктора с оператором new внутри функции происходит следующее:
  - Создается пустой объект, на который указывает переменная this. Этот объект 
    наследует прототип функции.
  - К объекту, хранимому в this, добавляются свойства и методы.
  - Объект, хранимый в this, неявно возвращается в конце функции (т.к. мы ничего
    не возвращали явно).

!!! под капотом ещё происходит это:
    this.__proto__ = Cat.prototype;
    
    А это значит, что у инстанса, ссылка __proto__ будет указывать на prototype
    конструктора которым была создана.

Пример:
function B() {}
B.prototype.x = 10;

const b = new B();
console.log(b.x); // 10
console.log(b.y); // undefined

B.prototype = {constructor:B, x:10, y:20};

console.log(b.x); // 10
console.log(b.y); // undefined
/* А при таком подходе B.prototype = {constructor:B, x:10, y:20}; добавления свойств в прототип
с экземпляром ничего не происходит */

const b1 = new B();
console.log(b1.x); // 10
console.log(b1.y); // 20
/* Зато у последующих потомков появляются все новые свойства */

b instanceof B; // false
b1 instanceof B // true
/* Более того оказывается что придедущие потомки уже и не потомки вовсе */

Так происходит, потому что мы создаём новые объект, на который будет ссылаться B,
а instanceof  говорит true в случае если у конструктора и инстанса ссылка друг на друга.
Смотреть картинку.




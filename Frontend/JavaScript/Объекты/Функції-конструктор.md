## Функції-конструктори

### У JavaScript конструктор є звичайною функцією і тому визначається так

```js
function Cat(name) {
    this.name = name;
    this.say() {
        return "I am" + this.name;
    };
};
```

### При виклику конструктора з оператором `new` всередині функції

-   Створюється порожній об'єкт, на який вказує змінна `this`. Цей об'єкт успадковує прототип функції
-   До об'єкта, що зберігається в `this`, додаються властивості та методи
-   Об'єкт, що зберігається в `this`, неявно повертається в кінці функції (ми нічого не повертали явно)

### Що відбувається під «капотом»

У інстансу, посилання `__proto__` буде вказувати на `prototype` конструктора, яким була створена (`this.__proto__ = Cat.prototype`)

```js
function B() {}
B.prototype.x = 10;

const b1 = new B();
console.log(b1.x); // 10
console.log(b1.y); // undefined

// за такого підходу додавання властивостей у прототип, з екземпляром нічого не відбувається
B.prototype = { constructor: B, x: 10, y: 20 };

console.log(b.x); // 10
console.log(b.y); // undefined

// Зате у наступних нащадків з'являються нові властивості
const b2 = new B();
console.log(b2.x); // 10
console.log(b2.y); // 20

// Більше того виявляється, що попередні нащадки вже і не нащадки зовсім
console.log(b1 instanceof B); // false
console.log(b2 instanceof B); // true

// Так відбувається, тому що ми створюємо новий об'єкт, на який буде посилатися B, а instanceof говорить true, якщо у конструктора і інстанса посилання один на одного.
```

### Посилання

<a href="https://habr.com/ru/post/151070/">Функції-конструктори</a>

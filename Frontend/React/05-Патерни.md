## Патерни (шаблони проектування)

Готові способи рішення, підхід до написання коду

### Односпрямований потік даних

Дані передаються як водоспад, зверху вниз, від батька до дитини через props

### Елементи-властивості

Як значення властивості можна передавати React-елемент. Так можна створювати елементи «контейнери» або елементи, які вміють вибирати, що рендерити залежно від умови (завантаження, помилка)

```jsx
const card = <Card title={<p>Hello</p>} />;
```

### Клонування елементів

React-елементи не можна змінювати (вони вважаються immutable), але можна створювати модифіковані копії за допомогою React.cloneElement, наприклад, елементам можна додавати нові властивості

### Композиція

Об'єднання компонентів для того, щоб створити нові компоненти. За допомогою композиції ми можемо перепикористати якийсь компонент, додавши йому частину логіки

### Higher Order Component (компонент вищого порядку)

Функція (реалізація патерна Декоратор в React), яка приймає компонент та повертає новий компонент, провівши з ним якусь роботу. HOC підштовхують нас писати абстрактний код

#### Мета використання

-   Створення нових компонентів
-   Повторне використання коду
-   Зберігання локального стану компонентів

#### Композиція HOC

-   Композиція — застосування однієї функції до результату іншої
-   Ми можемо використовувати кілька «ефектів» HOC

#### Трансформація властивостей

-   HOC може перетворити властивості перед тим, як передавати їх компоненту (наприклад, змінювати їх імена і вибирати які саме властивості потрібно передати)
-   За допомогою додаткової функції (mapMethodsToProps) можна визначати цю поведінку для кожного компонента

### Проксі-компонент

Компонент вищого рівня, який буде перенаправляти props компонент рівнем нижче. Ми зробили компонент-обертку над картковою, куди винесли логіку показу потрібного лейбу «новий» або «на розпродажі», так як логіка у таких карток може відрізнятися сильно, логічно це винести в різні файли

-   Зворотний бік «гнучкості» компонентів це громіздка конфігурація
-   Код буде більш читабельним, якщо винести деталі конфігурації в окремі компоненти, для цього можна використовувати HOC або просто написати компонент-обгортку вручну

```jsx
// Proxy-component.jsx
export default ({ className = "", ...restProps }) => (
    <Product className={`product--sale ${className}`} {...restProps} />
);

// ProductList.jsx
const getComponentByType = (type, product) => {
    switch (type) {
        case Type.SALE:
            return <ProductSale product={product} />;
        case Type.NEW:
            return <ProductNew product={product} />;
    }

    return <Product product={product} />;
};

export const ProductList = ({ className = "", ...restProps }) => (
    <ul className="products">
        {products.map((product) => (
            <li key={product.id}>
                {getComponentByType(product.type, product)}
            </li>
        ))}
    </ul>
);
```

### Render-функція

Патерн React коли ви передає в React-компонент функцію, яка рендерить частини компонента (або всього компонента). Гарною особливістю є те, що в таку функції можна передавати аргументи, на які можна спиратися вище по ієрархії та робити потрібні зміни. Таким чином можна зробити взаємозв'язок між компонентом і місцем де нашу render-функцію оголошено

```jsx
const card = <Card renderBody={() => <p>Hello</p>} />;
```

### Рендер-пропс

-   Компоненту можна передавати одну з властивостей, помістивши його в тіло елемента
-   Ця властивість доступна через props.children
-   Підтримує будь-які типи даних (елементи, функції, об'єкт)
-   Компонент може вирішувати, як саме використовувати children
-   При передачі дочірніх компонентів використовуючи children, якщо два елементи inline, потрібно явно розділити їх пропуском
-   Робити з children функцію, а не компонент, вважається поганим тоном, для передачі функції потрібно використовувати render-функцію

#### React.Children

-   Функція React.Children.map() полегшує обробку props.children
-   Child-елементи можна замінювати, обертати в інші компоненти або приховувати (якщо повернути null)
-   Функція cloneElement клонує і повертає новий React-елемент, використовуючи елемент в якості відправної точки

```jsx
export const ItemDetails = ({ data, children }) => {
    const itemList = Children.map(children, (child) => {
        return cloneElement(child, { data });
    });

    return <div> {itemList}</div>;
};
```

### Умовний рендеринг

Метод який в залежності від умови повертатиме той чи інший компонент

```jsx
/**
 * Використання &&.
 *
 * product.type є — повернемо <mark>product.type<mark>
 * product.type немає — повернемо null
 */
const element = product.type && <mark>product.type<mark>;
```

```jsx
/**
 * Використання ||.
 *
 * product.type є — повернемо product.type
 * product.type немає — повернемо `Артикул ${product.id}`
 */
const element = product.type || `Артикул ${product.id}`;
```

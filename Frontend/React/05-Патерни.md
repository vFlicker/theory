## Патерни (шаблони проектування)

Готові способи рішення, підхід до написання коду

### Односпрямований потік даних

Дані передаються як водоспад, зверху вниз, від батька до дитини через props

### Умовний рендеринг

Метод який в залежності від умови повертатиме той чи інший компонент

```jsx
/**
 * Використання &&.
 *
 * product.type є — повернемо <mark>product.type<mark>
 * product.type немає — повернемо null
 */
const element = product.type && <mark>product.type<mark>;
```

```jsx
/**
 * Використання ||.
 *
 * product.type є — повернемо product.type
 * product.type немає — повернемо `Артикул ${product.id}`
 */
const element = product.type || `Артикул ${product.id}`;
```

### Елементи-властивості

Як значення властивості можна передавати React-елемент. Так можна створювати елементи «контейнери» або елементи, які вміють вибирати, що рендерити залежно від умови (завантаження, помилка)

```jsx
const card = <Card title={<p>Hello</p>} />;
```

### Render-функція

Патерн React коли ви передає в React-компонент функцію, яка рендерить частини компонента (або всього компонента). Гарною особливістю є те, що в таку функції можна передавати аргументи, на які можна спиратися вище по ієрархії та робити потрібні зміни. Таким чином можна зробити взаємозв'язок між компонентом і місцем де нашу render-функцію оголошено

```jsx
const card = <Card renderBody={() => <p>Hello</p>} />;
```

### Рендер-пропс

-   Компоненту можна передавати одну з властивостей, помістивши його в тіло елемента
-   Ця властивість доступна через props.children
-   Підтримує будь-які типи даних (елементи, функції, об'єкт)
-   Компонент може вирішувати, як саме використовувати children
-   При передачі дочірніх компонентів використовуючи children, якщо два елементи inline, потрібно явно розділити їх пропуском
-   Робити з children функцію, а не компонент, вважається поганим тоном, для передачі функції потрібно використовувати render-функцію

#### React.Children

-   Функція React.Children.map() полегшує обробку props.children
-   Child-елементи можна замінювати, обертати в інші компоненти або приховувати (якщо повернути null)
-   Функція cloneElement клонує і повертає новий React-елемент, використовуючи елемент в якості відправної точки

```jsx
export const ItemDetails = ({ data, children }) => {
    const itemList = Children.map(children, (child) => {
        return cloneElement(child, { data });
    });

    return <div> {itemList}</div>;
};
```

#### Клонування елементів

React-елементи не можна змінювати (вони вважаються immutable), але можна створювати модифіковані копії за допомогою React.cloneElement, наприклад, елементам можна додавати нові властивості

### Композиція

Об'єднання компонентів для того, щоб створити нові компоненти. За допомогою композиції ми можемо перепикористати якийсь компонент, додавши йому частину логіки

### Higher Order Component (компонент вищого порядку)

Функція (реалізація патерна Декоратор в React), яка приймає компонент та повертає новий компонент, провівши з ним якусь роботу. HOC підштовхують нас писати абстрактний код

#### Мета використання

-   Створення нових компонентів
-   Повторне використання коду
-   Зберігання локального стану компонентів

#### Важливо пам'ятати

-   Якщо поміняти HOC і місцями, можна щось зламати
-   Передані props — неявні залежності. Буває складно зрозуміти, звідки приходять props, в порівнянні з імпортуванням безпосередньо поведінки, від якого залежать компоненти, що його використовують
-   Застосування безлічі HOC-ів з великою кількістю props може призвести до колізій props

#### Задачі які підходять

-   Ця поведінка потрібна не для якогось одного компонента, а для багатьох (а то й усіх) компонентів у додатку
-   Ця поведінка не вимагає купи props, що використовує цю поведінку
-   Компоненти можуть використовуватися і власними силами, без цієї поведінки їх HOC-а
-   Не потрібно додавати свою логіку до компонента, який обернутий HOC

#### Краще не використовувати коли

-   Поведінка вимагає додавання купи props до компонентів
-   Поведінка застосовується лише у одному компоненті
-   Поведінка має налаштовуватись для кожного компонента, що використовує цю поведінку

#### Композиція HOC

-   Композиція — застосування однієї функції до результату іншої
-   Ми можемо використовувати кілька «ефектів» HOC

#### Трансформація властивостей

-   HOC може перетворити властивості перед тим, як передавати їх компоненту (наприклад, змінювати їх імена і вибирати які саме властивості потрібно передати)
-   За допомогою додаткової функції (mapMethodsToProps) можна визначати цю поведінку для кожного компонента

#### Імпорт HOC'ів

Можна обгортати компонент у HOC під час імпорту чи експорту. Якщо використовувати HOC під час експорту потрібно писати експорт двічі

-   Дефолтний експорт обгорнутого компонента
-   Звичайний експорт «чистого» компонента

### HOC vs Композиція

```jsx
function Button({ title, handleClick }) {
    return <button onClick={handleClick}>{title}</button>;
}

/**
 * HOC.
 *
 * Використовуючи такий підхід, ми можемо надати
 * будь-якому компоненту (<Button />, <Card />, <Logo />)
 * додаткову функціональність (виклик alert).
 */
const withAlert = (Component) => {
    return (props) => {
        const { alertMessage, handleClick = () => {} } = props;

        return (
            <Component
                {...props}
                handleClick={() => {
                    handleClick();
                    alert(alertMessage);
                }}
            />
        );
    };
};

/**
 * Композиція.
 *
 * Використовуючи такий підхід, щод додати додаткову
 * функціональність (виклик alert), треба буде створювати
 * нові компоненти (<AlertButton />, <AlertButtonCard />,
 * <AlertButtonLogo />).
 */
function AlertButton({ title, handleClick, alertMessage }) {
    return (
        <Button
            title={title}
            handleClick={() => {
                handleClick();
                alert(alertMessage);
            }}
        />
    );
}
```

### Проксі-компонент

Компонент вищого рівня, який буде перенаправляти props компонент рівнем нижче. Ми зробили компонент-обертку над картковою, куди винесли логіку показу потрібного лейбу «новий» або «на розпродажі», так як логіка у таких карток може відрізнятися сильно, логічно це винести в різні файли

-   Зворотний бік «гнучкості» компонентів це громіздка конфігурація
-   Код буде більш читабельним, якщо винести деталі конфігурації в окремі компоненти, для цього можна використовувати HOC або просто написати компонент-обгортку вручну

```jsx
const Btn = ({ className, primary, ...props }) => (
    <button
        type="button"
        className={classnames("btn", primary && "btn-primary", className)}
        {...props}
    />
);

const PrimaryBtn = (props) => <Btn {...props} primary />;
```

```jsx
// Proxy-component.jsx
export default ({ className = "", ...restProps }) => (
    <Product className={`product--sale ${className}`} {...restProps} />
);

// ProductList.jsx
const getComponentByType = (type, product) => {
    switch (type) {
        case Type.SALE:
            return <ProductSale product={product} />;
        case Type.NEW:
            return <ProductNew product={product} />;
    }

    return <Product product={product} />;
};

export const ProductList = ({ className = "", ...restProps }) => (
    <ul className="products">
        {products.map((product) => (
            <li key={product.id}>
                {getComponentByType(product.type, product)}
            </li>
        ))}
    </ul>
);
```

### Компонент-контейнер

-   Презентацій компонент — отримує props, відповідає тільки за рендеринг
-   Компонент-контейнер — приховує роботу зі store, реалізує loading, error, використовує dispatch, effects. Передає презентаційному компоненту props. Такі компоненти іноді виносять в окремі файли (ComponentContainer) або директорію `/containers`

### Memoization (мемоізація)

Збереження виконання (кешування) функції для запобігання повторним обчисленням

-   React.memo — для компонентів
-   React.useCallback — для колбеків
-   React.useMemo() — для складних обчислень

--- Полезное ---

1) В структуре данных нет булева значения, вместо этого у вопроса есть тип, и типы есть у ответов.

2) Игра на / лучше, чем на /game, тем что если у нас есть треки, которые пользователь может
 послушать, на / они кэшируются, а не /game, начнут загружаться.

3) Как писать классы:
 - статические методы — если в методе ни разу не использовали this, он должен стать static,
   нужны для того, чтобы не пересоздавать их лишний раз, то есть static метод один на все instance;
 - геттеры;
 - сеттеры;
 - конструктор;
 - основные методы;
 - унаследованные методы;
 - приватные методы (методы которые написал разработчик, например _getScreen).

4) Интерфейс — описание того, как должен выглядеть (вести себя) объект или метод, без имплементации.
 Обычно описывается как набор методов, для каждого из которых указываются типы аргументов и тип
 возвращаемого значения.

5) Именование обработчиков:
 - onClick — именование встроенных в React-элементов обработчиков (обработчик с приставкой on
используют только в props);
 - clickHandler — именование созданных разработчиками функций-обработчиков.

6) {question: -1} — в массиве вопросы начинаются с 0 индекса, поэтому не нужно менять тип данных,
 не нужно писать дополнительные проверки (так, например, если нет элементов массива indexOf показывает -1,
 чтобы код не упал).

7) Кэширование функции происходит когда мы передаём listener не анонимную функцию, а ссылку, на функцию.

8) Разница в использовании this.handlerClick.bind(this) и () => this.handlerClick в том,
 что this.handlerClick.bind(this), мы вызываем в constructor(), поэтому функция создаться всего 1 раз,
 из-за Reconciliation-алгоритма React, constructor() будет вызван всего 1 раз.

9) handlerSubmit можно вынести из функционального компонента, хороший тон.

10) Можно оборачивать компонент в HOC при импорте или экспорте. Если использовать HOC при экспорте
 нужно писать экспорт два раза:
 - дефолтный экспортировать обёрнутого компонента;
 - обычный экспорт "чистого" компонента.

11) Обычно принято Props объявлять в файле с компонентом, а то на основе чего собирается Props
 хранить где-то в отдельной папке, например папка types на уровне reducers, selectors.

12) Лучше state и props размещать вверху файла, а вспомогательные типы, ниже.

13) Custom Error. Нужны для того, чтобы удобно показывать сообщение об ошибке,
 код ошибки. Catch мы пишем, чтобы приложение не сломалось, и ошибка полетела дальше, по Promise.

 Например: в API в catch, Custom Error ошибку, если не смогли распарсить ответ. Тут нужен catch,
 чтобы прокинуть ошибку дальше по Promise, и вне catch, кидаем Custom Error, чтобы ошибка была понятной.

 Дальше в action, мы должны написать catch, и обработать ошибку, мы просто кидаем диспатч, на ошибку,
 если не напишем catch сломается приложение (плюс в консоли будет ошибка).

14) Вот в каких случаях HOC-и не очень уместны:
 - Поведение требует добавления кучи пропсов в компоненты.
 - Поведение применяется только в одном компоненте.
 - Поведение должно настраиваться для каждого компонента, использующего это поведение.

Задачи подходят для HOC-ов, если:
 - Это поведение нужно не для какого-то одного компонента, а для многих (а то и всех) компонентов в приложении
 - Это поведение не требует кучи пропсов, использующего это поведение
 - Компоненты могут использоваться и сами по себе, без этого поведения их HOC-а.
 - Не нужно добавлять свою логику к компоненту, который обернут HOC-ом.

15) Middleware для логінга, щоб не додавати ф-цію logeIn по 10 разів.
16) apiService.interceptors.response.use -- тут можно логувати помилки сервера.
--- ! Полезное ---

--- Лекция #5 (Бизнес-логика и хранение состояния) ---

1) Бизнес (Business / дело, занятие) логика — правила и ограничения реального мира, которые описываются
 с помощью компьютерной программы. Например, сеанс игры "Угадай мелодию", можно провести с друзьями в жизни
 без компьютера. Бизнес логика это часть логики которая может существовать без программы.

2) Бизнес-логика:
 - проверка, правильно ли пользователь ответил на вопрос;
 - подсчёт очков в игре;
 - поиск места в списке лучших.

3) Не бизнес-логика:
 - обработка событий;
 - срабатывание таймера;
 - окончание загрузки;
 - поиск DOM-элемента.

4) Хранение логики поверки правильного ответа пользователя.
 - там же где используется view:
    - логика по обработке ответов лежит там же, где пользователь отвечает;
    - компонент нельзя использовать повторно: он слишком завязан на свою логику, не абстрактным;
    - сложно искать конкретную логику: чтобы найти ответ на конкретный вопрос, нужно найти
      компонент этого вопроса в дереве;
    - сложно писать тексты.
 - в компоненте верхнего уровня (App):
   - вся логика по обработке любых ответов находится в одном месте;
   - компонент становится более универсальным — абстрактным, может работать с различной бизнес-логикой;
   - компонент становится слишком большим и начинает знать обо всём;
   - в компоненте становится сложно ориентироваться;
   - сложно писать тесты, нужно поднимать React, DOM и много дополнительных инструментов.

5) React в MVC это V:
 - React иерархический, это значит, что одни компоненты вкладываются в другие, а доступ
   снаружи есть только через props компонента верхнего уровня (App);
 - если нужно передать данные в глубоко вложенный компонент, нужно спускать их через App;
 - сложно обновлять данные: props у App нужно изменять каждый раз, когда изменяется состояние
   state, при этом нужно избежать лишнего повторного рендеринга;
 - App становится очень сложным, в нём приходится работать с большими объемами данных.

6) Flux
 - архитектурный паттерн, придуманный в Facebook;
 - даёт контроль над потоком данных;
 - отвечает на вопрос: как распространяются данные в приложении;
 - управляет данными;
 - вводит новые сущности: Action, Store, Dispatch, View.

7) Flux решает проблемы: 
 - передачи данных по иерархии;
 - большая вложенность;
 - передачи данных только через props;
 - перерисовки при изменении props (перерисовка происходит по цепочке, и могут перерисовываться
   компоненты, который просто передают props дальше);
 - усложняется root-компонент;
 - отсутствуют связей одного уровня.

8) Flux не решает вопросы:
 - связи между компонентами (мы сами должны определять, кто должен подписываться на изменения об
   обновлении хранилища, и сами решаем какие компоненты должны закидывать данные в хранилище);
 - когда перерисовывать представление;
 - как загружать данные.

9) Action (действие):
 - описывает действия;
 - действие должно быть атомарным и решать одну задачу;
 - отвечает на вопрос «что сделать»;
 - обязательно содержит имя;

10) Хороший action:
 - увеличить количество ошибок;
 - перейти к следующему вопросу;
 - тикнуть таймером.

11) Плохой action:
 - проверить, правильно ли пользователь ответил на вопрос и перейти к следующему вопросу
   или увеличить количество ошибок;
 - проверить, осталось ли у пользователя время и, если да, то увеличить таймер на единицу,
   в противно случае записать пользователю поражение.

12) Dispatcher (диспетчер), можно сравнить с Controller:
 - менеджер;
 - передаёт хранилищу информацию о событии.

13) Store (хранилище);
 - состояние приложения:
 - данные могут изменяться только на основании действий;
 - предоставляет интерфейсы для получения данных.

14) View (представление):
 - представление информации;
 - компоненты.

15) Redux (state менеджер) — библиотека, реализующая паттерн Flux:
 - единый источник правды (single source of truth) — можем организовать глобальное хранилище
   которое, содержит единственную полную версию всех данных для приложения. Все изменения
   фиксируются нём и всегда известно, что данные в хранилище актуальны;
 - хранилище изменяется с помощью reducer;
 - однонаправленная синхронизация из хранилища во View через подписку;
 - обратная синхронизация View-Store работает через Action;
 - хранилище связано с компонентами не напрямую, а через connect.

14) Паттерн Action creators — подход, при котором actions создаются не руками внутри кода, а через
 внешний метод:
 - дополнительная логика не хранится в коде компонента, а лежит отдельно, где её можно повторно
   использовать или протестировать;
 - компонент становится ещё более абстрактным: он знает о чём именно сообщаться внешнему миру,
   но при этом не знает деталей протокола.

15) connect — связывает логику приложения и хранилища. Это компонент-обёртка, который через методы
 mapStateToProps и mapDispatchToProps "знакомит" между собой React-компонент и Redux-хранилище.

16) mapStateToProps — метод, преобразующий state Redux в props компонента. При каждом изменении
 хранилища, изменяются props компонента через это метод.

17) mapDispatchToProps — позволяет внедрить dispatch действия вызывая функции из props.

18) dispatch — передаёт action в reducer.

19) Две версии компонента — connect(MyComponent) создаёт версию MyComponent связанную с reducer
 для того, чтобы работать со storage. При этом исходную версию MyComponent, можно использовать
 повторно для других задач или для тестирования.

20) Flux:
 - единый источник правды (single source of truth);
 - однонаправленная синхронизация из хранилища во View через подписку;
 - обратная синхронизация View-Store работает через Action.

21) Redux:
 - хранилище изменяется с помощью reducer;
 - хранилище связано с компонентами не напрямую, а через connect.

--- ! Лекция #5 (Бизнес-логика и хранение состояния) ---


--- Лекция #6 (Работа с сетью) ---

1) API:
 - синхронизация данных с внешним миром: получение данных, синхронизация;
 - получение состояния пользователя.cx

1) Работа с API:
 Любые запросы к сети не возвращают результат мгновенно, поэтому Action не может вернуть данные
 мгновенно — нужно добавить какое-то промежуточное состояние.

2) Middleware — программы, которые используются как "клей" для описания взаимодействия программ
 или частей программы. Позволяет разделить единый код программы на небольшие составные части,
 каждую из которых можно тестировать и повторно использовать вне зависимости от других частей.

3) Плюсы Middleware:
 - единообразная работа с большими объёмами входящей информации (например, одинаковая реакция на
   все ошибки в запросах на сервер);
 - отдельные тесты на каждую отдельную Middleware-программу;
 - повторное использование и лёгкая замена Middleware.

3) Redux Middleware — "посредник" для работы с асинхронными Actions.

4) Библиотека Thunk — добавляет возможность работать с Actions асинхронно, с помощью Promise:
 - dispatch может принять на вход Promise, вместо Action;
 - если в dispatch был передан объект, dispatch работает как обычно;
!- если Promise — dispatch вызовется, когда Promise перейдёт в состояние Resolved.

!!) Пакет redux-thunk — это middleware. С её помощью мы расширяем функциональность Redux,
 получая возможность делать dispatch (отправлять) не только объекты, описывающие действия,
 но и функции. В них мы можем разместить код с побочными эффектами.

5) Axios — библиотека для сетевых запросов:
 - добавляет mock для более удобного тестирования;
 - имеет удобный интерфейс для написания сетевых запросов — не требует сложного конфигурирования;
 - пропускает все запросы через один объект, поэтому позволяет писать "перехватчики"
   запросов — middleware, способные обрабатывать одинаковые запросы, например все ошибки;
 - всё запросы со статусами отличными от 2хх, определяет как error, что позволяет отловить их catch();
 - позволяет легко отменять запросы.

4) Reselect:
 - функция принимает state и возвращает данные из него;
 - скрывает внутреннюю архитектуру store от пользователя;
 - можно делать сложные выборки из store используя библиотеку reselect.

--- ! Лекция #6 (Работа с сетью) ---


--- Лекция #7 (Оптимизация) ---

1) Что можно оптимизировать:
 - производительность: сделать приложение более быстрым и отзывчивым;
 - код: сделать код более простым, понятным и легко расширяемым;
 - процессы: ускорить процессы ревью и доставки новых версий пользователю.

2) Сложности оптимизации:
 - производительность кода обратно пропорциональна его читабельности;
 - оптимизация требует анализа;
 - преждевременная оптимизация отнимает время и может не дать результата.

3) Оптимизация кода:
 - Рефакторинг:
  - пишите код для людей, а не машин;
  - не повторяйтесь (DTY);
  - единица кода (функция, метод, класс) должны решать одну задачу;
 - внедрение дополнительных инструментов для оптимизации кода;
 - упрощаем код, выбрасываем все лишнее;
 - применяем уже знакомые нам паттерны;
 - изучаем новые паттерны;

 - оптимизация качества кода повлияет на производительность;
 - оптимизировать нужно когда есть проблемы с производительностью, иначе это
   преждевременная оптимизация;
 - оптимизировать нужно, то что работает медленно, иначе это
   преждевременная оптимизация.

5) Как обнаружить проблемы с производительностью:
 - спросить у пользователя;
 - воспользоваться анализатором:
   - dynatrace;
     PageSpeed Insight.
 - воспользоваться профайлером:
   - Chrome devtools вкладка Performance;
   - React Profiler.
 - посчитать самому:
   - console.time();
   - why-did-you-update.

6) Best Practices для производительности в React:
 - использовать PureComponent:
   - передавать удобно сравнимые props;
   - кэширование обработчиков;
 - не использовать PureComponent, если много props или props всегда уникальны, например
   передаются всегда функции которые не равны друг другу.

7) Memoization — сохранение выполнения (кеширование) функции для предотвращения повторных вычислений.

8) Memoization в React:
 - React.meno() — для компонентов;
 - React.useCallback() — для коллбэков; 
 - React.useMemo() — для сложных вычислений.

9) Оптимизация React-компонентов. Итог:
 - Functional Component first;
 - Memoization (useCallback, useMemo, React.memo);
 - Не переусложнять props;
 - Кешировать обработчики, когда это уместно;
 - Production сборка;
 - React Profiler.

--- ! Лекция #7 (Оптимизация) ---


--- Лекция #8 (Тестирование) ---
1) Тестирование помогает убедиться, что приложение работает так, как требуется.

2) Условно авто-тесты можно разделить на:
 - $ unit-тесты — проверяют логику в отдельных компонентах кода, тестируют
   маленькую функциональность (как работает функция, как работает метод, создаётся ли правильный объект);
 - $$ интеграционные тесты — проверяют как взаимодействуют между собой разные части программы;
 - $$$ UT Tests (end-to-end) — проверяют правильность работы сценариев, которые могут включать в себя работу
   нескольких компонент, а могут ограничиваться одним.

3) Существует два популярных подхода к тестированию:
 - Test Driven Development (TDD) / Behavior-Driven Development (BDD) — написание компонентов
   через создание тестов к ним;
 - Test-Last Development (TLD) — написание тестов на уже существующие компоненты.

 Test Driven Development:
  - методология подхода к написанию программ на основе тестов, ключевой момент в разработке через
    тестирование даже не само написание тестов, до кода, а именно короткие итерации написания полностью
    протестированного кода;
  - сначала пишутся тест для того, чтобы закрепить поведение программы, а потом пишется код, на котором
    тесты будут выполняться без ошибок;
  - разработка ведется короткими итерациями по определенному алгоритму:
    - написать тест: тест используется для описания функциональности, формализует задачу;
    - запустить тесты и проверить проходят ли они проверки: не должны;
    - написать код: как не должен быть идеальным, он просто должен выполнять задачу;
    - запустить тесы: проверить проходят ли они;
    - оптимизировать код: оптимизировать алгоритмы, расположение модулей.

 Behavior-Driven Development:
  - набор практик и подходов к написанию тестов;
  - основан на подходе TDD;
  - диктует стиль написания и формулирования тестов, говорит о таком стиле написания тестов при котором
    любой читающий тест может понять, что происходит в тесте и чем занимается тестируемый код.

4) Какими бывают программы:
    - исследовательский код — используется один раз, чтобы получить быстрое решение;
    - прототип — программируется быстро, чтобы в боевом режиме проверить решение. Через короткое
      время устаревает и переписывается как готовый продукт;
    - готовый продукт — код пишется так, чтобы работать максимально эффективно и решать поставленную
      перед ним задачу.

5) Код работает правильно если пользователь видит интерфейс, который был задуман автором. Интерфейс решает
 задачи, для которых он создавался:
  - компоненты должны использоваться так, как задумано;
  - картинка, что видит пользователь должна быть полной;
  - взаимодействия с интерфейсом должны быть предсказуемыми.

6) Инструменты для тестирования:
 - среда для тестирования — файлы запускаются в браузере или Node.js;;
 - тестовый фреймворк — программа, которая запускает тесты, предоставляет хороший
   интерфейс для тестирования, описывает структуру файла с тестами,
   заводит понятие группы тестов и тестового случая.
 - assertion-библиотека: библиотека для проверки выражений, проверяет правильно ли написан код.

7) Jest — тестовый-фреймворк и assertion-библиотека, тесно интегрированные с React.
8) React Testing Library — набор вспомо гательных функций, позволяющий тестировать
 React-компоненты не полагаясь на их внутреннюю реализацию.

9) Mock данные:
 - в тестах нельзя использовать настоящие данные, потому что они могут скачиваться по сети или
   постоянно изменяться. В этом случае мы не можем гарантировать, что результаты получатся
   одинаковыми, поэтому в тестах для компонент используются mock-данные;
 - node.js не умеет работать с DOM, поэтому для отрисовки используется renderer / Enzyme: функция,
   которая создаёт похожую на DOM-структуру, чтобы можно было проверить, что React работает правильно,
   но не использовать для этого настоящий DOM;
 - команда jest.fn() создаёт функцию для тестирования, она работает как обычная функция, но в неё
   добавляются дополнительные записи, например, она помнит сколько раз её вызывали, какие были
   параметры во время вызовов и какие значения она возвращала;
 - при тестировании компонентов, нужно использовать необходимый минимум mock данных, те данные,
   что не используются в тестировании, могут быть пустыми или отсутствовать;
 - несмотря на то, что для теста используется минимальный набор данных, интерфейс всё равно должен
   оставаться правильным. Не стоит опускать обязательный параметр только потому, что он не
   используется в тесте или делать его необязательным для теста.

10) Пример сценария для сквозного теста:
 - React корректно рендерит компонент приветственного экрана:
   - в DOM есть все нужные элементы;
 - пользователь нажимает на кнопку "начать игру":
   - симуляция события на клик по DOM-элементу кнопки;
   - проверка, что обработчик, добавленный на кнопку был вызван и отработал;
 - React рендерит первый игровой экран:
   - в DOM есть все нужные элементы.

--- ! Лекция #8 (Тестирование) ---

--- Полезное ---

1) В структуре данных нет булева значения, вместо этого у вопроса есть тип, и типы есть у ответов.

2) Игра на / лучше, чем на /game, тем что если у нас есть треки, которые пользователь может
 послушать, на / они кэшируются, а не /game, начнут загружаться.

3) Как писать классы:
 - статические методы — если в методе ни разу не использовали this, он должен стать static,
   нужны для того, чтобы не пересоздавать их лишний раз, то есть static метод один на все instance;
 - геттеры;
 - сеттеры;
 - конструктор;
 - основные методы;
 - унаследованные методы;
 - приватные методы (методы которые написал разработчик, например _getScreen).

4) Интерфейс — описание того, как должен выглядеть (вести себя) объект или метод, без имплементации.
 Обычно описывается как набор методов, для каждого из которых указываются типы аргументов и тип
 возвращаемого значения.

5) Именование обработчиков:
 - onClick — именование встроенных в React-элементов обработчиков (обработчик с приставкой on
используют только в props);
 - clickHandler — именование созданных разработчиками функций-обработчиков.

6) {question: -1} — в массиве вопросы начинаются с 0 индекса, поэтому не нужно менять тип данных,
 не нужно писать дополнительные проверки (так, например, если нет элементов массива indexOf показывает -1,
 чтобы код не упал).

7) Кэширование функции происходит когда мы передаём listener не анонимную функцию, а ссылку, на функцию.

8) Разница в использовании this.handlerClick.bind(this) и () => this.handlerClick в том,
 что this.handlerClick.bind(this), мы вызываем в constructor(), поэтому функция создаться всего 1 раз,
 из-за Reconciliation-алгоритма React, constructor() будет вызван всего 1 раз.

9) handlerSubmit можно вынести из функционального компонента, хороший тон.

10) Можно оборачивать компонент в HOC при импорте или экспорте. Если использовать HOC при экспорте
 нужно писать экспорт два раза:
 - дефолтный экспортировать обёрнутого компонента;
 - обычный экспорт "чистого" компонента.

11) Обычно принято Props объявлять в файле с компонентом, а то на основе чего собирается Props
 хранить где-то в отдельной папке, например папка types на уровне reducers, selectors.

12) Лучше state и props размещать вверху файла, а вспомогательные типы, ниже.

13) Custom Error. Нужны для того, чтобы удобно показывать сообщение об ошибке,
 код ошибки. Catch мы пишем, чтобы приложение не сломалось, и ошибка полетела дальше, по Promise.

 Например: в API в catch, Custom Error ошибку, если не смогли распарсить ответ. Тут нужен catch,
 чтобы прокинуть ошибку дальше по Promise, и вне catch, кидаем Custom Error, чтобы ошибка была понятной.

 Дальше в action, мы должны написать catch, и обработать ошибку, мы просто кидаем диспатч, на ошибку,
 если не напишем catch сломается приложение (плюс в консоли будет ошибка).

14) Вот в каких случаях HOC-и не очень уместны:
 - Поведение требует добавления кучи пропсов в компоненты.
 - Поведение применяется только в одном компоненте.
 - Поведение должно настраиваться для каждого компонента, использующего это поведение.

Задачи подходят для HOC-ов, если:
 - Это поведение нужно не для какого-то одного компонента, а для многих (а то и всех) компонентов в приложении
 - Это поведение не требует кучи пропсов, использующего это поведение
 - Компоненты могут использоваться и сами по себе, без этого поведения их HOC-а.
 - Не нужно добавлять свою логику к компоненту, который обернут HOC-ом.

15) Middleware для логінга, щоб не додавати ф-цію logeIn по 10 разів.
16) apiService.interceptors.response.use -- тут можно логувати помилки сервера.
--- ! Полезное ---

--- Лекция #2 (Состояние приложения и адресная строка) ---

1) Состояние — набор изменяющихся параметров системы. Состояние устойчиво до тех пор,
 пока над объектом не будет произведено действие, после этого стояние может измениться.

2) Переменные параметры:
 - фильтры: дата заезда/выезда, количество гостей и комнат;
 - сортировка: сначала дешевые от 2 звезд;
 - номер открытой страницы;
 - режим отображения.

 Все эти состояния разрознены, а значит, чтобы воспроизвести это состояние, нужно вручную
повторить полный набор действий от начала до конца, который привел к этому состояния.

3) Адресная строка:
 - может сохранить текущее состояние приложения;
 - помогает воспроизвести иное состояние;
 - дополнительный инструмент взаимодействия.

4) Взаимодействие через адресную строку:
 - при сохранении состояния в адресной строке меняется схема взаимодействия компонент. Изменение
   состояния компонента не вызывает прямую перерисовку, а только изменение адреса. А компоненты
   в свою очередь реагируют на изменение адреса. Свящующим звеном выступает React Router.

5) Сложные состояния:
 - такой подход позволяет создавать компоненты, которые изменяют состояние многих элементов
   на странице.

6) Location API — адресная строка со стороны JavaScript.
7) History API — позволяет эмулировать перемещение по страницам приложения.

8) pushState или location.hash:
 - location.hash = '/login': http://locakhost:3000/#login/;
 - history.pushState(null, null, 'login'): http://locakhost:3000/login;
 - одно или другое стоит выбирать в зависимости от того, насколько хорошо ваш сервер
   взаимодействует с приложением. Если записать состояние через pushState() и обновить
   страницу — браузер запросит другую страницу, и тут в дело вступает уже сервер.

9) Отличие <Router component={myComponent} /> от
   <Router render={() => {} />} от
   <Router> <myComponent /> </Router>:
 - если нам нужно передать просто компонент, нужно использовать component:
   component={} ожидает ссылку на компонент: component={MyScreen},
   такой компонент БУДЕТ заново создаваться;
 - если нам нужно передать дополнительные параметры мы можем сделать это используя render:
   render={} возвращает функцию с компонентом внутри render={() => <MyComponent renderScreen={this._getScreen}},
   такой компонент НЕ БУДЕТ заново создаваться;
 - если мы передадим компонент как children, он не получит дополнительные служебные свойства от Router,
   такой компонент НЕ БУДЕТ заново создаваться.

--- ! Лекция #2 (Состояние приложения и адресная строка) ---


--- Лекция #3 (React-компоненты) ---


9) Виды форм:
 - с управляемыми элементами управления (за поведение элементов полностью отвечает React):
   - значение поля хранится в состоянии;
   - значение изменяется через prop-callback;
   - логика обработки смены значения полностью на разработчике;
 - с неуправляемыми элементами управления (за поведение отвечает браузер);
 - смешанные.

--- ! Лекция #3 (React-компоненты) ---


--- Лекция #4 (React и паттерны) ---

1) Архитектура:
 - структура проекта (сущности, директории и тд.);
 - инструментарий;
 - взаимодействие между компонентами;
 - взаимодействие с внешней средой.x

2) Задачи архитектуры:
 - упростить разработку;
 - задать вектор разработки;
 - установить ограничения.

3) Разработка архитектуры:
 - с чего нужно начать:
   - с вопросов;
 - сколько времени потратить:
   - долгосрочная разработка;
   - прототип (MVP minimum viable product / Минимально жизнеспособный продукт) — нужен для того, чтобы
     проверить концепции и идеи на которые прямо сейчас нет ответа, в нём максимально упрощаются все не
     интересующие моменты, но выделяется время тому, что непонятно на этапе проектирования;
   - краткосрочная разработка;
 - на сколько сложно разработать архитектуру (если ли смысл делать хорошо, или продукт нужен на одну
   черную пятницу).

4) Архитектурные решения (паттерны):
 - паттерны (шаблоны проектирования) — готовые способы решение; подход к написанию кода;
 - архитектура в отдельно взятом компоненте, классе, функции и тд.;
 - архитектура вырастает из архитектурных решений.

5) Однонаправленный поток данных — данные передаются как водопад, сверху вниз, от родителя к ребенку, через props.

6) Условный рендеринг (паттерн React) — метод который в зависимости от условия буду возвращать тот
 или иной компонент, или логическое &&, или логическое ||:
 - использование &&:
   если product.type есть, вернём следующее условие, если product.type нет вернём null:
   product.type && <mark>product.type<mark>;
 - использование ||:
   если product.type есть, вернём product.type, если product.type нет вернём следующее условие:
   product.type || 'Артикул product.id'.

7) Делегирование (паттерн React) — часть работы перекладываем на другие компоненты (children, render-props):
 - при передаче дочерних компонентов используя children, если два элемента inline, нужно явно
   разделить их пробелом <span />{' '}<span />;
 - делать из children функцию, а не компонент, считается дурным тоном, для передачи функции нужно использовать
   render-props;
 - render-props — хорош тем, что в него можно передавать аргументы, на которые можно опираться выше по
   иерархии и делать нужные изменения. Таким образом можно сделать взаимосвязь между, компонентом и местом
   где наш render-prop объявлен.

8) Композиция (в React преобладает над Наследованием) — объединение компонентов для того, чтобы создать
 новые компоненты. С помощью композиции мы можем переиспользовать какой-нибудь компонент, добавив ему часть логики.

9) Proxy-component — компонент более высокого уровня, который будет перенаправлять props в компонент уровнем ниже.
 Мы сделали компонент-обёртку над карточной, куда вынесли логику показал нужного label "новый" или "на распродаже",
 так как логика у таких карточек может отличаться сильно, логично это всё вынести в разные файлы.


 // proxy component для распродажи
 export default (props) => {
   const {className = '', ...restProps} = props;

   return (
     <Product
       className={`product--sale ${className}`}
       {...restProps}
   );
 }

  // ProductList
  const getComponentByType = (type, product) => {
    switch (type) {
      case: Type.SALE:
        return <ProductSale product={product} />;
      case: Type.NEW:
        return <ProductNew product={product} />;
    }

    return <Product product={product} />
  });

  export default (props) => {
    return (
      <ul className="products">
        {
          products.map((product) => {
            <li key={product.id}>
              {getComponentByType(product.type, product)}
            </li>
          })
        }
  }

10) HOC (Higher Order Component / Компонент высшего порядка) — реализация паттерна Декоратор в React.
 HOC это функция, которая принимает компонент и возвращает новый компонент, проведя с ним какую-то работу,
 применяется для:
 - для создания новых компонентов;
 - для повторного использования кода;
 - подталкивают нас писать абстрактный код;
 - для хранения локального state компонентов.

11) Хук useRef — дает возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе.
 Создаёт состояние так же как и useState, особенность в том, что мы получаем объект, а не две переменных как в
 useState. Благодаря useRef, может реализовать логику сохранение предыдущего стейта, сохранять количество
 рендеров компонента.

 https://github.com/vladilenm/react-hooks-course/blob/master/src/examples/ref.js

 Когда использовать Ref:
  - сохранение данных между перерисовками;
  - управление фокусом, выделение текста или воспроизведение медиа;
  - императивный вызов анимаций;
  - интеграция со сторонними DOM-библиотеками;
  - если форма с большим количеством контролов (браузер сам хорошо работает с формами).

 Компонент должен быть уже нарисован на странице:
   componentDidMount() {
     const input = this._inputRef.current.focus();
   }

12) Хук useMemo — позволяет закэшировать вычисляемое значение, так мы оптимизировали
 наш код, чтобы огромное вычисление не происходило каждую перересовку, если не изменились
 deps.

 Так же может закэшировать объект, например если в useEffect, зависимость это объект,
при сравнении, одинаковых объектов будет false, поэтому тут помогает useMemo.
https://github.com/vladilenm/react-hooks-course/blob/master/src/examples/memo.js

13) Хук useCallback, принцип как у useMemo, только кэшируем функцию, потому что две одинаковые
 функции не равны друг другу.

 ОТЛИЧИЕ вот useMemo в том, что в useMemo мы получаем return из коллбэка,
 а в useCallback, коллбэка который передаём в useCallback.

 function useInput(initialValue) {
   const [value, setValue] = useState(initialValue)

   const onChange = event => {
     setValue(event.target.value)
   }

   const clear = () => setValue('')

   return {
     bind: {value, onChange},
     value,
     clear
   }
 }

 function App() {
   const input = useInput('')

   return (
     <div className={'container pt-3'}>
       <input type="text" {...input.bind} />

       <button className="btn btn-warning" onClick={() => input.clear()}>Очистить</button>
       <hr />
       <h1>{input.value}</h1>
     </div>
   )
 }

--- ! Лекция #4 (React и паттерны) ---


--- Лекция #5 (Бизнес-логика и хранение состояния) ---

1) Бизнес (Business / дело, занятие) логика — правила и ограничения реального мира, которые описываются
 с помощью компьютерной программы. Например, сеанс игры "Угадай мелодию", можно провести с друзьями в жизни
 без компьютера. Бизнес логика это часть логики которая может существовать без программы.

2) Бизнес-логика:
 - проверка, правильно ли пользователь ответил на вопрос;
 - подсчёт очков в игре;
 - поиск места в списке лучших.

3) Не бизнес-логика:
 - обработка событий;
 - срабатывание таймера;
 - окончание загрузки;
 - поиск DOM-элемента.

4) Хранение логики поверки правильного ответа пользователя.
 - там же где используется view:
    - логика по обработке ответов лежит там же, где пользователь отвечает;
    - компонент нельзя использовать повторно: он слишком завязан на свою логику, не абстрактным;
    - сложно искать конкретную логику: чтобы найти ответ на конкретный вопрос, нужно найти
      компонент этого вопроса в дереве;
    - сложно писать тексты.
 - в компоненте верхнего уровня (App):
   - вся логика по обработке любых ответов находится в одном месте;
   - компонент становится более универсальным — абстрактным, может работать с различной бизнес-логикой;
   - компонент становится слишком большим и начинает знать обо всём;
   - в компоненте становится сложно ориентироваться;
   - сложно писать тесты, нужно поднимать React, DOM и много дополнительных инструментов.

5) React в MVC это V:
 - React иерархический, это значит, что одни компоненты вкладываются в другие, а доступ
   снаружи есть только через props компонента верхнего уровня (App);
 - если нужно передать данные в глубоко вложенный компонент, нужно спускать их через App;
 - сложно обновлять данные: props у App нужно изменять каждый раз, когда изменяется состояние
   state, при этом нужно избежать лишнего повторного рендеринга;
 - App становится очень сложным, в нём приходится работать с большими объемами данных.

6) Flux
 - архитектурный паттерн, придуманный в Facebook;
 - даёт контроль над потоком данных;
 - отвечает на вопрос: как распространяются данные в приложении;
 - управляет данными;
 - вводит новые сущности: Action, Store, Dispatch, View.

7) Flux решает проблемы: 
 - передачи данных по иерархии;
 - большая вложенность;
 - передачи данных только через props;
 - перерисовки при изменении props (перерисовка происходит по цепочке, и могут перерисовываться
   компоненты, который просто передают props дальше);
 - усложняется root-компонент;
 - отсутствуют связей одного уровня.

8) Flux не решает вопросы:
 - связи между компонентами (мы сами должны определять, кто должен подписываться на изменения об
   обновлении хранилища, и сами решаем какие компоненты должны закидывать данные в хранилище);
 - когда перерисовывать представление;
 - как загружать данные.

9) Action (действие):
 - описывает действия;
 - действие должно быть атомарным и решать одну задачу;
 - отвечает на вопрос «что сделать»;
 - обязательно содержит имя;

10) Хороший action:
 - увеличить количество ошибок;
 - перейти к следующему вопросу;
 - тикнуть таймером.

11) Плохой action:
 - проверить, правильно ли пользователь ответил на вопрос и перейти к следующему вопросу
   или увеличить количество ошибок;
 - проверить, осталось ли у пользователя время и, если да, то увеличить таймер на единицу,
   в противно случае записать пользователю поражение.

12) Dispatcher (диспетчер), можно сравнить с Controller:
 - менеджер;
 - передаёт хранилищу информацию о событии.

13) Store (хранилище);
 - состояние приложения:
 - данные могут изменяться только на основании действий;
 - предоставляет интерфейсы для получения данных.

14) View (представление):
 - представление информации;
 - компоненты.

15) Redux (state менеджер) — библиотека, реализующая паттерн Flux:
 - единый источник правды (single source of truth) — можем организовать глобальное хранилище
   которое, содержит единственную полную версию всех данных для приложения. Все изменения
   фиксируются нём и всегда известно, что данные в хранилище актуальны;
 - хранилище изменяется с помощью reducer;
 - однонаправленная синхронизация из хранилища во View через подписку;
 - обратная синхронизация View-Store работает через Action;
 - хранилище связано с компонентами не напрямую, а через connect.

14) Паттерн Action creators — подход, при котором actions создаются не руками внутри кода, а через
 внешний метод:
 - дополнительная логика не хранится в коде компонента, а лежит отдельно, где её можно повторно
   использовать или протестировать;
 - компонент становится ещё более абстрактным: он знает о чём именно сообщаться внешнему миру,
   но при этом не знает деталей протокола.

15) connect — связывает логику приложения и хранилища. Это компонент-обёртка, который через методы
 mapStateToProps и mapDispatchToProps "знакомит" между собой React-компонент и Redux-хранилище.

16) mapStateToProps — метод, преобразующий state Redux в props компонента. При каждом изменении
 хранилища, изменяются props компонента через это метод.

17) mapDispatchToProps — позволяет внедрить dispatch действия вызывая функции из props.

18) dispatch — передаёт action в reducer.

19) Две версии компонента — connect(MyComponent) создаёт версию MyComponent связанную с reducer
 для того, чтобы работать со storage. При этом исходную версию MyComponent, можно использовать
 повторно для других задач или для тестирования.

20) Flux:
 - единый источник правды (single source of truth);
 - однонаправленная синхронизация из хранилища во View через подписку;
 - обратная синхронизация View-Store работает через Action.

21) Redux:
 - хранилище изменяется с помощью reducer;
 - хранилище связано с компонентами не напрямую, а через connect.

--- ! Лекция #5 (Бизнес-логика и хранение состояния) ---


--- Лекция #6 (Работа с сетью) ---

1) API:
 - синхронизация данных с внешним миром: получение данных, синхронизация;
 - получение состояния пользователя.cx

1) Работа с API:
 Любые запросы к сети не возвращают результат мгновенно, поэтому Action не может вернуть данные
 мгновенно — нужно добавить какое-то промежуточное состояние.

2) Middleware — программы, которые используются как "клей" для описания взаимодействия программ
 или частей программы. Позволяет разделить единый код программы на небольшие составные части,
 каждую из которых можно тестировать и повторно использовать вне зависимости от других частей.

3) Плюсы Middleware:
 - единообразная работа с большими объёмами входящей информации (например, одинаковая реакция на
   все ошибки в запросах на сервер);
 - отдельные тесты на каждую отдельную Middleware-программу;
 - повторное использование и лёгкая замена Middleware.

3) Redux Middleware — "посредник" для работы с асинхронными Actions.

4) Библиотека Thunk — добавляет возможность работать с Actions асинхронно, с помощью Promise:
 - dispatch может принять на вход Promise, вместо Action;
 - если в dispatch был передан объект, dispatch работает как обычно;
!- если Promise — dispatch вызовется, когда Promise перейдёт в состояние Resolved.

!!) Пакет redux-thunk — это middleware. С её помощью мы расширяем функциональность Redux,
 получая возможность делать dispatch (отправлять) не только объекты, описывающие действия,
 но и функции. В них мы можем разместить код с побочными эффектами.

5) Axios — библиотека для сетевых запросов:
 - добавляет mock для более удобного тестирования;
 - имеет удобный интерфейс для написания сетевых запросов — не требует сложного конфигурирования;
 - пропускает все запросы через один объект, поэтому позволяет писать "перехватчики"
   запросов — middleware, способные обрабатывать одинаковые запросы, например все ошибки;
 - всё запросы со статусами отличными от 2хх, определяет как error, что позволяет отловить их catch();
 - позволяет легко отменять запросы.

4) Reselect:
 - функция принимает state и возвращает данные из него;
 - скрывает внутреннюю архитектуру store от пользователя;
 - можно делать сложные выборки из store используя библиотеку reselect.

--- ! Лекция #6 (Работа с сетью) ---


--- Лекция #7 (Оптимизация) ---

1) Что можно оптимизировать:
 - производительность: сделать приложение более быстрым и отзывчивым;
 - код: сделать код более простым, понятным и легко расширяемым;
 - процессы: ускорить процессы ревью и доставки новых версий пользователю.

2) Сложности оптимизации:
 - производительность кода обратно пропорциональна его читабельности;
 - оптимизация требует анализа;
 - преждевременная оптимизация отнимает время и может не дать результата.

3) Оптимизация кода:
 - Рефакторинг:
  - пишите код для людей, а не машин;
  - не повторяйтесь (DTY);
  - единица кода (функция, метод, класс) должны решать одну задачу;
 - внедрение дополнительных инструментов для оптимизации кода;
 - упрощаем код, выбрасываем все лишнее;
 - применяем уже знакомые нам паттерны;
 - изучаем новые паттерны;

 - оптимизация качества кода повлияет на производительность;
 - оптимизировать нужно когда есть проблемы с производительностью, иначе это
   преждевременная оптимизация;
 - оптимизировать нужно, то что работает медленно, иначе это
   преждевременная оптимизация.

5) Как обнаружить проблемы с производительностью:
 - спросить у пользователя;
 - воспользоваться анализатором:
   - dynatrace;
     PageSpeed Insight.
 - воспользоваться профайлером:
   - Chrome devtools вкладка Performance;
   - React Profiler.
 - посчитать самому:
   - console.time();
   - why-did-you-update.

6) Best Practices для производительности в React:
 - использовать PureComponent:
   - передавать удобно сравнимые props;
   - кэширование обработчиков;
 - не использовать PureComponent, если много props или props всегда уникальны, например
   передаются всегда функции которые не равны друг другу.

7) Memoization — сохранение выполнения (кеширование) функции для предотвращения повторных вычислений.

8) Memoization в React:
 - React.meno() — для компонентов;
 - React.useCallback() — для коллбэков; 
 - React.useMemo() — для сложных вычислений.

9) Оптимизация React-компонентов. Итог:
 - Functional Component first;
 - Memoization (useCallback, useMemo, React.memo);
 - Не переусложнять props;
 - Кешировать обработчики, когда это уместно;
 - Production сборка;
 - React Profiler.

--- ! Лекция #7 (Оптимизация) ---


--- Лекция #8 (Тестирование) ---
1) Тестирование помогает убедиться, что приложение работает так, как требуется.

2) Условно авто-тесты можно разделить на:
 - $ unit-тесты — проверяют логику в отдельных компонентах кода, тестируют
   маленькую функциональность (как работает функция, как работает метод, создаётся ли правильный объект);
 - $$ интеграционные тесты — проверяют как взаимодействуют между собой разные части программы;
 - $$$ UT Tests (end-to-end) — проверяют правильность работы сценариев, которые могут включать в себя работу
   нескольких компонент, а могут ограничиваться одним.

3) Существует два популярных подхода к тестированию:
 - Test Driven Development (TDD) / Behavior-Driven Development (BDD) — написание компонентов
   через создание тестов к ним;
 - Test-Last Development (TLD) — написание тестов на уже существующие компоненты.

 Test Driven Development:
  - методология подхода к написанию программ на основе тестов, ключевой момент в разработке через
    тестирование даже не само написание тестов, до кода, а именно короткие итерации написания полностью
    протестированного кода;
  - сначала пишутся тест для того, чтобы закрепить поведение программы, а потом пишется код, на котором
    тесты будут выполняться без ошибок;
  - разработка ведется короткими итерациями по определенному алгоритму:
    - написать тест: тест используется для описания функциональности, формализует задачу;
    - запустить тесты и проверить проходят ли они проверки: не должны;
    - написать код: как не должен быть идеальным, он просто должен выполнять задачу;
    - запустить тесы: проверить проходят ли они;
    - оптимизировать код: оптимизировать алгоритмы, расположение модулей.

 Behavior-Driven Development:
  - набор практик и подходов к написанию тестов;
  - основан на подходе TDD;
  - диктует стиль написания и формулирования тестов, говорит о таком стиле написания тестов при котором
    любой читающий тест может понять, что происходит в тесте и чем занимается тестируемый код.

4) Какими бывают программы:
    - исследовательский код — используется один раз, чтобы получить быстрое решение;
    - прототип — программируется быстро, чтобы в боевом режиме проверить решение. Через короткое
      время устаревает и переписывается как готовый продукт;
    - готовый продукт — код пишется так, чтобы работать максимально эффективно и решать поставленную
      перед ним задачу.

5) Код работает правильно если пользователь видит интерфейс, который был задуман автором. Интерфейс решает
 задачи, для которых он создавался:
  - компоненты должны использоваться так, как задумано;
  - картинка, что видит пользователь должна быть полной;
  - взаимодействия с интерфейсом должны быть предсказуемыми.

6) Инструменты для тестирования:
 - среда для тестирования — файлы запускаются в браузере или Node.js;;
 - тестовый фреймворк — программа, которая запускает тесты, предоставляет хороший
   интерфейс для тестирования, описывает структуру файла с тестами,
   заводит понятие группы тестов и тестового случая.
 - assertion-библиотека: библиотека для проверки выражений, проверяет правильно ли написан код.

7) Jest — тестовый-фреймворк и assertion-библиотека, тесно интегрированные с React.
8) React Testing Library — набор вспомо гательных функций, позволяющий тестировать
 React-компоненты не полагаясь на их внутреннюю реализацию.

9) Mock данные:
 - в тестах нельзя использовать настоящие данные, потому что они могут скачиваться по сети или
   постоянно изменяться. В этом случае мы не можем гарантировать, что результаты получатся
   одинаковыми, поэтому в тестах для компонент используются mock-данные;
 - node.js не умеет работать с DOM, поэтому для отрисовки используется renderer / Enzyme: функция,
   которая создаёт похожую на DOM-структуру, чтобы можно было проверить, что React работает правильно,
   но не использовать для этого настоящий DOM;
 - команда jest.fn() создаёт функцию для тестирования, она работает как обычная функция, но в неё
   добавляются дополнительные записи, например, она помнит сколько раз её вызывали, какие были
   параметры во время вызовов и какие значения она возвращала;
 - при тестировании компонентов, нужно использовать необходимый минимум mock данных, те данные,
   что не используются в тестировании, могут быть пустыми или отсутствовать;
 - несмотря на то, что для теста используется минимальный набор данных, интерфейс всё равно должен
   оставаться правильным. Не стоит опускать обязательный параметр только потому, что он не
   используется в тесте или делать его необязательным для теста.

10) Пример сценария для сквозного теста:
 - React корректно рендерит компонент приветственного экрана:
   - в DOM есть все нужные элементы;
 - пользователь нажимает на кнопку "начать игру":
   - симуляция события на клик по DOM-элементу кнопки;
   - проверка, что обработчик, добавленный на кнопку был вызван и отработал;
 - React рендерит первый игровой экран:
   - в DOM есть все нужные элементы.

--- ! Лекция #8 (Тестирование) ---

## Хуки

Хук — функція, що викликається при кожному перемальовуванні компонента. дає можливість компонентам-функціям працювати зі станом, життєвим циклом і контекстом, технічно це просто функції. Ім'я такої функції починається з use. React відстежує виклики цих функцій і при необхідності може змінити їхню поведінку та змінити результат виконання

### Мета

-   Запросити поріг входу у React
-   Мінімізувати код програми
-   Спростити перевикористання коду та позбутися HOC Wrapper Hell
-   Додати функціональним компонентам відсутні можливості
    -   Внутрішній стан
    -   Виконання сайд-ефектів
    -   Методи життєвого циклу

### Правила та обмеження

-   У компонентах важлива послідовність застосування хуків
-   Не можна використовувати в умовах та циклах
-   Можна використовувати тільки у компонентах та інших хуках (бо React пов'язує той стан який ми зберігаємо в хуках з конкретним екземпляром конкретного компонента, якщо ми намагаємося викликати хук зі звичайної функції, що не є React-компонентом, то React не знатиме яким чином зберегти ці дані, а потім коректно повернути їх назад
-   не можна застосовувати у класових компонентах
-   немає підтримки всіх методів життєвого (getSnapshotBeforeUpdate, getDerivedStateFromError, componentDidCatch)

### Хуки

#### useState

-   Додає state у функціональні компоненти
-   Повертає масив — поточне значення та функцію для встановлення нового значення
-   Завжди оновлює об'єкт повністю, а не окремі поля як setState

#### useContext

-   Отримує значення із заданого контексту
-   Код створення контексту та встановлення значення залишається без змін
-   В useContext передається саме об'єкт-контекст (а не Consumer)
-   Застосування
    -   Контекст потрібний для того, щоб вирішити проблему «глобальних даних»
    -   Замість того, щоб передавати props через усі шари програми, дані можна передавати через контекст
    -   З допомогою контексту ми зможемо зробити так щоб компоненти не створювали об'єкти сервісу, а отримали його
    -   Може бути корисним при реалізації функціоналу підтримки мов, тем або візуального оформлення
    -   Значення в контексті можна оновлювати, як будь-яку іншу властивість компонента

#### useEffect

-   Першим параметром приймає callback, другим масив залежностей при зміні яких буде викликатись даний хук
-   Запускає функцію щоразу, коли певний набір даних змінився
-   Якщо дані залежить від параметра (наприклад, id ресурсу) — потрібно вказувати їх у масиві
-   Якщо хочемо викликати використання ефекту один раз, потрібно передати порожній масив
-   Якщо callback повертає ще одну функцію callback, вона буде викликатися для очищення попереднього ефекту (схоже на componentWillUnmount)

```jsx
function Component({ id }) {
    const [data, setData] = useState();

    useEffect(() => {
        let cancelled = false;

        (async () => {
            const response = await fetch(url + id);
            const data = await response.json();

            !cancelled && setData(film);
        })();

        return () => {
            cancelled = true;
        };
    }, [id]);
}
```

```jsx
function Component({ id }) {
    const [data, setData] = useState();

    useEffect(() => {
        const controller = new AbortController();
        const { signal } = controller;

        (async () => {
            const response = await fetch(url + id, { signal });
            const data = await response.json();

            setData(film);
        })();

        return () => controller.abort();
    }, [id]);
}
```

#### useCallback

-   Зберігає функцію між викликами, якщо дані в масиві залежностей не змінилися
-   Використовується досить часто, коли хуки залежать від функції. Створювати нову функцію щоразу, як правило, не має сенсу, більше того, це може призвести до неправильної роботи програми. Потрібно використовувати хук useCallback, який запам'ятовує значення переданої функції і оновлює її лише тоді, коли дані у масиві змінилися з минулого виклику

```js
/**
 * f — функція з першого аргументу.
 */
const f = useCallback(() => loadData(id), [id]);
```

#### useMemo

-   Зберігає значення між викликами, якщо дані в масиві залежностей не змінилися
-   Працює практично так само як і хук useCallback, тільки useCallback кешує саму функцію, а useMemo кешує результат роботи цієї функції (оптимізація коду, щоб величезне обчислення не відбувалося кожної перемальовки, якщо не змінилися залежності)
-   Може закешувати об'єкт (якщо в useEffect залежність — об'єкт, при порівнянні однакових об'єктів отримаємо false, тут допомагає useMemo)

```js
/**
 * f — результат роботи функції з першого аргументу.
 */
const f = useMemo(() => getValue(id), [id]);
```

#### useReducer

-   Зазвичай використовується замість useState, коли у вас складна логіка стану, яка включає кілька значень, або коли наступний стан залежить від попереднього
-   Дозволяє винести логіку в окремий файл

```jsx
const initialState = { count: 0 };

function reducer(state, action) {
    switch (action.type) {
        case "increment":
            return { count: state.count + 1 };
        case "decrement":
            return { count: state.count - 1 };
        default:
            throw new Error();
    }
}

function Counter() {
    const [state, dispatch] = useReducer(reducer, initialState);
    return (
        <>
            Count: {state.count}
            <button onClick={() => dispatch({ type: "decrement" })}>-</button>
            <button onClick={() => dispatch({ type: "increment" })}>+</button>
        </>
    );
}
```

#### useRef

-   Дає можливість отримати доступ до DOM-вузлів або React-елементів, створених у render-методі
-   Створює стан так само як і useState, особливість в тому, що ми отримуємо об'єкт, а не дві змінні
-   Зберігає дані між перемальовками
-   Допомагає керувати фокусом, виділяти текст або програвання медіа
-   Допомагає з імперативним викликом анімацій
-   Допомагає зробити інтеграцію зі сторонніми DOM-бібліотеками
-   Корисний якщо форма з великою кількістю контролів (браузер добре працює з формами)

```jsx
/**
 * Компонент має бути вже намальований на сторінці
 */
class MyComponent extends React.Component {
    componentDidMount() {
        const input = this._inputRef.current.focus();
    }
}
```

```jsx
/**
 * callback-ref.
 *
 * Один з елементарних способів визначення положення
 * або розміру DOM-вузла це використання callback-ref.
 * React буде викликати цей колбек щоразу, коли реф
 * прив'язується до іншого вузла.
 */
function TextInputWithFocusButton() {
    const inputEl = useRef(null);
    const onButtonClick = () => {
        inputEl.current.focus(); // current вказує на змонтований елемент input
    };

    return (
        <>
            <input ref={inputEl} type="text" />
            <button onClick={onButtonClick}>
                Установить фокус на поле ввода
            </button>
        </>
    );
}
```

## React hooks

Хук — функція, що викликається при кожному рендері компонента. дає можливість компонентам-функціям працювати зі станом, життєвим циклом і контекстом, технічно це просто функції. Ім'я такої функції починається з use. React відстежує виклики цих функцій і при необхідності може змінити їхню поведінку та змінити результат виконання

### Мета

-   Запросити поріг входу у React
-   Мінімізувати код програми
-   Спростити перевикористання коду та позбутися HOC Wrapper Hell
-   Додати функціональним компонентам відсутні можливості
    -   Внутрішній стан
    -   Виконання сайд-ефектів
    -   Методи життєвого циклу

### Правила та обмеження

-   У компонентах важлива послідовність застосування хуків
-   Не можна використовувати в умовах та циклах
-   Можна використовувати тільки у компонентах та інших хуках (бо React пов'язує той стан який ми зберігаємо в хуках з конкретним екземпляром конкретного компонента, якщо ми намагаємося викликати хук зі звичайної функції, що не є React-компонентом, то React не знатиме яким чином зберегти ці дані, а потім коректно повернути їх назад
-   не можна застосовувати у класових компонентах
-   немає підтримки всіх методів життєвого (getSnapshotBeforeUpdate, getDerivedStateFromError, componentDidCatch)

### Хуки

#### useState

-   Додає state у функціональні компоненти
-   Повертає масив — поточне значення та функцію для встановлення нового значення
-   Завжди оновлює об'єкт повністю, а не окремі поля як setState

#### useContext

-   Отримує значення із заданого контексту
-   Код створення контексту та встановлення значення залишається без змін
-   В useContext передається саме об'єкт-контекст (а не Consumer)

#### useEffect

-   Першим параметром приймає callback, другим масив залежностей при зміні яких буде викликатись даний хук
-   Запускає функцію щоразу, коли певний набір даних змінився
-   Якщо дані залежить від параметра (наприклад, id ресурсу) — потрібно вказувати їх у масиві
-   Якщо хочемо викликати використання ефекту один раз, потрібно передати порожній масив
-   Якщо callback повертає ще одну функцію callback, вона буде викликатися для очищення попереднього ефекту (схоже на componentWillUnmount)

#### useCallback

-   Зберігає функцію між викликами, якщо дані в масиві залежностей не змінилися
-   Використовується досить часто, коли хуки залежать від функції. Створювати нову функцію щоразу, як правило, не має сенсу, більше того, це може призвести до неправильної роботи програми. Потрібно використовувати хук useCallback, який запам'ятовує значення переданої функції і оновлює її лише тоді, коли дані у масиві змінилися з минулого виклику

```js
/**
 * f — функція з першого аргументу.
 */
const f = useCallback(() => loadData(id), [id]);
```

#### useMemo

-   Зберігає значення між викликами, якщо дані в масиві залежностей не змінилися
-   Працює практично так само як і хук useCallback, тільки useCallback кешує саму функцію, а useMemo кешує результат роботи цієї функції

```js
/**
 * f — результат роботи функції з першого аргументу.
 */
const f = useMemo(() => getValue(id), [id]);
```

#### useReducer

-   Зазвичай використовується замість useState, коли у вас складна логіка стану, яка включає кілька значень, або коли наступний стан залежить від попереднього
-   Дозволяє винести логіку в окремий файл

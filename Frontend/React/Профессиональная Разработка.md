---------- Работа с сервером ----------

1. Использование функций:

-   функции, которые мы передаем компоненту могут быть не только обработчиками событий;
-   функция, к примеру, может инкапсулировать получение данных (тогда компонент становится независимым от источника данных).

1. Данные в React приложении:

-   централизовать управление данными — хорошая практики;
-   если данные нужно использовать в нескольких компонентах — их нужно хранить в родительском компоненте;
-   чтобы "поднять" данные вверх по иерархии компонентов, используют события.

5. API-клиент:

-   код, который работает с сетью лучше изолировать в отдельный класс-сервис;
-   компоненты не должны знать откуда именно берутся данные;
-   такой подход упростит тестирование и поддержку кода работающего с API.

6. Трансформация данных в API:

-   изолируйте код, который обрабатывает данные;
-   отделяйте модель данных API от модели данных проложения.

7. Хорошее приложение не отображает элементы для которых нет данных.

8. Логика индикатора загрузки:

-   "состояние" загрузки можно хранить в state;
-   с зависимости от этого состояния, рендерим индикатор загрузки или содержимое компонента (уже с данными);
-   старайтесь разделять логику и рендеринг;
-   React.Fragment позволяет группировать элементы не создавая лишних DOM-объектов.

9. Обработка ошибок:

-   в state добавим поле, где будет хранить флаг: нужно ли отобразить ошибку;
-   в зависимости от этого флага, отображаем ошибку или нормальное содержимое компонента.

10. Итоги:

-   React ничего не знает о работе с сервером — это задачу других библиотек;
-   сетевой код следует изолировать от кода компонентов;
-   если необходимо, трансформируйте данные до того, как их получит компонент;
-   обрабатывайте состояние "загрузка" и "ошибка";
    !- разделяйте ответственность компонентов: логику и рендеринг.

---------- ! Работа с сервером ----------

---------- Redux ----------

1. Введение в Redux:

-   Redux решает проблему управления состоянием в приложении;
-   Redux предлагает хранить state в одном "глобальном" объекте;
-   функция Reducer обновляет глобальный state в ответ на Action (действие);
-   Объект Store координирует обновления.

2. Библиотеки:

-   redux — сам Redux;
-   react-redux — библиотека, которая упрощает интеграцию между React и Redux.

3. Reducer:

-   Reducer это обычная функция: (state, action) => newState;
-   если state — undefined, тогда нужно вернуть первоначальный (initial) state;
-   если тип action неизвестен — нужно вернуть state без изменений.

4. Redux Store:

-   Store координирует работу с данными в Redux приложении.

5. Чистые функции:

-   возвращаемое значение зависит только от аргументов (для одинаковых аргументов чистая функция
    всегда будет возвращать одинаковые результаты);
-   у функции нет побочных эффектов (обновления глобальной переменной, обновление DOM-дерева,
    запись значения в кэш, запись в БД, модифицирование аргументов, вызов таймаута, вызов сервера и тд.);
-   reducer это чистая функция (зависит исключительно от state и action которые он получил).

6. UI для Redux:

-   в качестве UI может использоваться любая библиотека или фреймворк;
-   store.dispatch(action) используется для обновления состояния;
-   store.subscribe(listener) используется для обновления UI.

7. Действия с параметрами:

-   кроме типа, любое действие (action) может содержать дополнительную информацию;
-   часто дополнительные параметры передаются в поле payload.

8. Action Creator — функция, которая создает объект action.

9. Структура проекта:

-   есть несколько подходов к структуре Redux проекта;
-   один из подходов — вынести reducer-функции и action creator функции в отдельные файлы или папки.

10. bindActionCreators:

-   bindActionCreators() — связывает функцию action creator с функцией dispatch();
-   созданные таким способом функции делают сразу два действия — создание действия (action) и отправка
    action в dispatch;
-   const {add, remove} = bindActionCreators(actions).

11. React и Redux:

-   React должен "знать" когда нужно обновлять компоненты (store.subscribe должен сказать об
    обновлении state);
-   React компоненты должны быть как можно меньше связаны с Redux.

12. react-redux и функция connect:

-   react-redux упрощает интеграцию react + redux;
-   Provider делает store доступным всему дереву компонентов (через контекст);
-   connect() — компонент высшего порядка, которые передает значения из store в компонент.

13. mapDispatchToProps:

-   mapDispatchToProps() — второй аргумент для функции connect();
-   созданные функции будут переданы в компонент, таким способом компонент может обновить
    состояние в store.

14. mapDispatchToProps как объект:

-   Action Creator необязательно должен быть чистой функцией;
-   если второй аргумент connect() это объект, то результат будет таким же как для кода:
    const mapDispatchToProps = (dispatch) => bindActionCreators(actions, dispatch);
    connect(mapStateToProps, mapDispatchToProps)(Counter).

---------- ! Redux ----------

---------- Разработка Redux приложения ----------

1. Вспомогательные компоненты:

-   большинству приложений необходимы вспомогательные компоненты (ErrorBoundary, Context, HOC);
-   эти и другие вспомогательные компоненты лучше создавать сразу (до начала работы над основным
    функционалом приложения).

2. Redux компоненты:

-   для того чтобы создать Redux приложение, нужно определить функцию-reducer;
-   функции action-creators необязательно использовать, но на практики они присутствуют всегда;
-   логику создания store удобно вынести в отдельный файл.

3. Dispatch:

-   чтобы получить данные из service и передать их в Redux Store мы использовали два HOC:
    withBookstoreService() — получает сервис из контекста и передает в компонент,
    connect() — оборачивает функцию dispatch из Redux Store;
-   mapDispatchToProps — может быть функцией или объектом, если это объект, он передается в
    bindActionCreators().

4. Принцип работы компонента BookList с Redux:

-   в нашем приложении начинаем с пустого массива в Redux Store;
-   как только наш компонент загружается, функция connect() оборачивает наш компонент BookList в
    HOC, который подключается к Redux Store, мы конфигурируем то, как происходит это подключение
    с помощью при помощи функций mapStateToProps и mapDispatchToProps;
-   mapStateToProps — описывает то, какие именно данные наш компонент хочет получить из Redux Store;
-   mapDispatchToProps — описывает то, какие именно действия хочет выполнить наш компонент (какие
    actions он будет передавать в store);
-   когда наш компонент появляется на экране мы:
    -   получаем из контекста bookstoreService при помощи HOC withBookstoreService();
    -   получаем данные используя bookstoreService();
    -   вызываем функцию booksLoaded().
-   booksLoaded — это уже не обычный action creator, он не просто создаёт действие, а автоматически
    передаёт этот самый action в Redux Store;
-   мы передаём те данные которые получили от bookstoreService в Redux Store;
-   Redux Store вызывает наш reducer;
-   reducer получает action 'BOOKS_LOADED' и обновляет список книг в state;
-   обновленный список книг снова возвращается к нашему компоненту BookList;
-   через mapStateToProps(), наш компонент получает обновленный список книг и в функции render
    показывает этот список на экране.

5. Асинхронные данные.
   Реализовать загрузку данных в Redux можно так-же, как и в обычном React приложении, для этого нужно:

-   добавить поле loading в Redux state;
-   обновлять это поле в reducer, когда данные становятся доступны;
-   передать значение loading в компонент, используя mapStateToProps.

6. setState и reducer:

-   в setState() можно передавать только ту часть state, которую нужно обновить;
-   reducer должен вернуть полный объект: return {...state, updatedProp: newValue};

7. Обработка ошибок:

-   ошибку поученных данных, нужно сохранить в store, затем компонент сможет её отобразить;
-   чтобы сохранить ошибку, нужно создать отдельное действие (BOOK_FETCH_ERROR);
-   саму ошибку можно передать вместе с действием и сохранить в store.

8. Аргумент ownProps — свойство нашего компонента которое он получил сверху от других компонентов,
   в нашем случае от withBookstoreService(). Мы вынесли логику обработку данных из componentDidMount в
   отдельную функции которую мы создали внутри mapDispatchToProps(), раньше mapDispatchToProps был объект,
   мы сделали из него функцию, что позволило получить доступ к dispatch и ownProps.

9. Action fetchBooks() возвращает функцию, потому что мы не хотим чтобы наш компонент, который будет
   вызывать fetchBooks напрямую зависел от этих параметров, наш компонент должен просто вызвать fetchBooks()
   без аргументов и запустить процесс получения книг.

10. Naming Convention:

-   FETCH_BOOKS_REQUEST — запрос отправлен;
-   FETCH_BOOKS_SUCCESS — получен результат (в payload передаются полученные данные);
-   FETCH_BOOKS_FAILURE — произошла ошибка (в payload передается объект Error).

11. Компоненты-контейнеры:

-   презентационные компоненты — отвечают только за рендеринг;
-   компоненты-контейнеры — работают с Redux, реализуют loading, error и другую логику (такие компоненты
    иногда выносят в отдельные файлы "PersonContainer" или папки "/containers").

12. Новый компонент:

-   начните с создания нового презентационного компонента, он не должен "знать" о Redux;
-   обновите state, добавьте туда новые поля;
-   для начала заполните state тестовыми данными;
-   реализуйте функции для connect() и подключите компонент к Redux.

13. Добавление в массив:

-   в Redux-приложения, так же как и в React нельзя модифицировать state;
-   добавлять элемент в массив нужно так: return {items: [...state.items, item]}.

14. Организация кода reducer:

-   как только reducer становится сложным — сразу упрощайте его;
-   работайте со структурой глобального state: объединяйте свойства в объекты;
-   выносите логику обновления объектов из глобального state в отдельные функции.

15. Store Enhancer управляет процессов создания store. Возвращает новую реализацию createStore.

16. Middleware — функции, которые последовательно вызываются при обработке действий:
    const logAll = (store) => (next) => (action) => {}, используются намного чаще, чем Store Enhancer.

17. Thunk middleware — позволяет передавать в store функции как действия. Такие функции принимают
    dispatch() и getState().

---------- ! Разработка Redux приложения ----------

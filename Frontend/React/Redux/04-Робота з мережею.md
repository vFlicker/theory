## Робота з мережею

Дані в React-Redux додатку приходять не з серверу, а з де-якої прокладки BLL (business logic layer)

### API-клієнт

-   Код, який працює з мережею, краще ізолювати в окремий клас-сервіс
-   Компоненти не повинні знати, звідки саме беруться дані
-   Такий підхід спростить тестування та підтримку коду, що працює з API

### Логіка індикатора завантаження

-   Додати поле loading до Redux state
-   Оновлювати це поле в reducer, коли дані стануть доступними
-   Передати значення loading в компонент
-   Залежно від стану loading, рендерити індикатор завантаження або вміст компонента (вже з даними)

### Обробка помилок

-   Помилка отриманих даних, потрібно зберегти в store, потім компонент зможе її відобразити

### Асинхронність

Будь-які запити до мережі не повертають результат миттєво, тому Action не може повернути дані миттєво – потрібно додати якийсь проміжний стан

-   React нічого не знає про роботу з сервером — це завдання інших бібліотек
-   Мережний код слід ізолювати від коду компонентів
-   Якщо необхідно, трансформуйте дані до того, як їх отримає компонент
-   Хороша програма не відображає елементи для яких немає даних
-   Обробляйте стан «завантаження» та «помилка»
-   Розділяйте відповідальність компонентів — логіку та рендеринг
-   Функція, може інкапсулювати отримання даних (тоді компонент стає незалежною від джерела даних)

### Redux Thunk

Пакет redux-thunk — це middleware. З його допомогою ми розширюємо функціональність Redux, отримуючи можливість робити dispatch (надсилати) не тільки об'єкти, що описують дії, а й функції. Такі функції приймають dispatch і getState, у них ми можемо розмістити код із побічними ефектами

```js
const getData = () => (dispatch) => {
    return fetch("https://jsonplaceholder.typicode.com/posts")
        .then((response) => response.json())
        .then((json) => {
            /**
             * Навіть middleware зрештою відправлятиме дії
             * з простимиб об'єктами за допомогою цього
             * методу.
             */
            dispatch({ type: "DATA_LOADED", payload: json });
        });
};
```

### Redux Saga

Пакет redux-saga — це middleware для керування побічними ефектами. З його допомогою ми чітко розділити синхронну та асинхронну логіку

```js
/**
 * store/actions.js
 */
const getData = (id) => ({
    type: "DATA_REQUESTED",
    payload: { id },
});

/**
 * store/sagas.js
 */
import { takeEvery, call, put } from "redux-saga/effects";

const getData = (id) => fetch(`https://jsonplaceholder.typicode.com/posts/${id}`)
    .then((response) => response.json());

/**
 * 1. Взяти кожен action з назвою "DATA_REQUESTED" і для
 * кожного з цих action запускати worker saga.
 *
 * 2. Всередині worker saga викликається функція
 * під назвою getData.
 *
 * 3. Якщо функція успішна, тоді надсилаємо новий action
 * з назвою "DATA_LOADED" разом із payload.
 *
 * 4. Якщо функція видає помилку, тоді надсилаємо новий
 * action під назвою "API_ERRORED" разом із payload.
 */
export default function* watcherSaga() {
    yield takeEvery("DATA_REQUESTED", workerSaga);
}

function* workerSaga(action) {
    try {
        const payload = yield call(getData, action.payload.id);
        yield put({ type: "DATA_LOADED", payload });
    } catch (evt) {
        yield put({ type: "API_ERRORED", payload: evt });
    }
}
```

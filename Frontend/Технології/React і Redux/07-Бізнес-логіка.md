## Бізнес-логіка

Правила та обмеження реального світу, які описуються за допомогою комп'ютерної програми. Бізнес-логіка є частиною логіки, яка може існувати без програми. Наприклад, сеанс гри «Вгадай мелодію» можна провести з друзями в житті без комп'ютера

-   Перевірка, чи правильно користувач відповів на запитання
-   Підрахунок очок у грі
-   Пошук місця у списку найкращих

### Зберігання логіки

#### Там де використовується View

-   Складно шукати конкретну логіку (потрібно у дереві знайти компонент, де розміщена бізнес-логіка)
-   Компонент не можна використовувати повторно (він занадто зав'язаний на свою логіку і не є не абстрактним)
-   Складно писати тексти

#### У компоненті верхнього рівня (App.jsx)

-   Вся бізнес-логіка знаходиться в одному місці
-   Компоненти стають більш універсальними (абстрактними)
-   Компоненти можуть працювати з різною бізнес-логікою
-   Компонент верхнього рівня стає занадто великим і починає знати про все, у ньому доводиться працювати з великими обсягами даних
-   У компоненті верхнього рівня стає стає складно орієнтуватися
-   Якщо потрібно передати дані у глибоко вкладений компонент, потрібно спускати їх через App
-   В App props змінюються щоразу, коли змінюється state, при цьому слід уникнути зайвого ререндерингу
-   Складно писати тести

## Flux

Вид архітектури, яку Facebook використовує, щоб працювати з React

-   Дає контроль над потоком даних
-   Керує тим, як поширюються дані у додатку
-   Керує даними
-   Вводить нові сутності — Action, Store, Dispatch, View

### Flux вирішує проблеми

-   Передачі даних по ієрархії лише через props
-   Великої вкладеності
-   Ререндерингу при зміні props
-   Ускладнення root-компоненту (більше не треба зберігати всю бізнес-логіку в ньому)
-   Відсутні зв'язків на різних рівнях (зміна шапки при додавання товару в кошик)

### Flux не вирішує проблеми

-   Зв'язку між компонентами (ми самі маємо визначати, хто має підписуватися на зміни про оновлення сховища, і самі вирішуємо які компоненти повинні закидати дані до сховища)
-   Коли перемальовувати View
-   Як завантажувати дані

### Сутності Flux

#### Action (дія)

-   Описує дію, яка є атомарною і вирішує одне завдання
-   Містить ім'я, яке відповідає на питання: «що зробити?»
-   Крім типу, будь-яка дія може містити додаткову інформацію (часто передається у полі payload)

#### Dispatcher (диспетчер)

-   Передає сховищу інформацію про подію

#### Store (сховище)

-   Стан програми
-   Координує роботу з даними в програмі
-   Дані можуть змінюватися тільки на підставі actions (дій)
-   Надає інтерфейси для отримання даних

```js
/**
 * Використовується для оновлення стану.
 */
store.dispatch(action);

/**
 * Використовується оновлення UI.
 */
store.subscribe(listener);
```

#### View (відображення)

-   Відображення інформації
-   Компоненти

## Redux

Бібліотека (state менеджер), що реалізує патерн Flux

-   Вирішує проблему керування станом у додатку
-   Пропонує зберігати state в одному «глобальному» об'єкті (single source of truth)
-   Об'єкт Store координує оновлення
-   Reducer чиста функція (залежить виключно від state та action, які він отримав) оновлює глобальний state у відповідь на action або повертає старий state, якщо action не підійшов
-   Односпрямована синхронізація зі сховища в View через підписку
-   Зворотна синхронізація View-Store працює через action
-   Як UI може використовуватись будь-яка бібліотека або фреймворк

### Flux і Redux

-   Flux

    -   Єдине джерело правди
    -   Односпрямована синхронізація зі сховища в View через підписку
    -   Зворотна синхронізація View-Store працює через action

-   Redux

    -   Сховище змінюється з допомогою Reducer
    -   Сховище пов'язане з компонентами не безпосередньо, а через connect

#### connect

Компонент вищого порядку, який пов'язує логіку програми та сховища (передає значення зі store компонент). Через методи mapStateToProps і mapDispatchToProps «знайомить» між собою React-компонент та Redux-сховище. Створює нову версію компонента пов'язану з reducer для того, щоб працювати зі сховищем. При цьому початкову версію компонента можна використовувати повторно для інших завдань або тестування. MapStateToProps та MapDispatchToProps — спрацьовують на кожен render, але компонент не перемальовується, якщо у нас MapStateToProps повернув об'єкт з тим самими значеннями state

-   mapStateToProps — перший аргумент для функції connect. Метод, що перетворює стан Redux в props компонента. Аргумент ownProps — властивості компонента, які він отримав зверху від інших компонентів. При кожній зміні сховища змінюються props компонента через цей метод

-   mapDispatchToProps — другий аргумент для функції connect, може буду об'єктом або функцією, яки приймає два аргументи dispatch і ownProps. Створені функції будуть передані компонент, таким чином компонент може оновити стан у store

```jsx
const MapStateToProps = (state) => ({
    // rerender не буде
    users: state.usersPage.users, // usersPage має те саме посилання
    pageSize: state.usersPage.pageSize, // usersPage має те саме посилання
});
```

### Action Creators

Функція, яка створює об'єкт action

-   Додаткова логіка не зберігається в коді компонента, а лежить окремо, де її можна повторно використовувати чи протестувати
-   Компонент стає ще абстрактнішим, знає про що саме повідомлятися зовнішньому світу, але при цьому не знає деталей протоколу
-   Action Creator необов'язково має бути чистою функцією

### Middleware

Функції, які послідовно викликаються при обробці дій. Дозволяє розділити єдиний код програми на невеликі складові, кожну з яких можна тестувати та повторно використовувати незалежно від інших частин

-   Одноманітна робота з великими обсягами вхідної інформації (наприклад, однакова реакція на всі помилки у запитах на сервер)
-   Окремі тести на кожну окрему програму Middleware
-   Повторне використання та легка заміна Middleware

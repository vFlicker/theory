## Робота з мережею

Дані в React-Redux додатку приходять не з серверу, а з де-якої прокладки BLL (business logic layer)

## Асинхронність

Будь-які запити до мережі не повертають результат миттєво, тому Action не може повернути дані миттєво – потрібно додати якийсь проміжний стан

-   React нічого не знає про роботу з сервером — це завдання інших бібліотек
-   Мережний код слід ізолювати від коду компонентів
-   Якщо необхідно, трансформуйте дані до того, як їх отримає компонент
-   Хороша програма не відображає елементи для яких немає даних
-   Обробляйте стан «завантаження» та «помилка»
-   Розділяйте відповідальність компонентів — логіку та рендеринг
-   Функція, може інкапсулювати отримання даних (тоді компонент стає незалежною від джерела даних)

### API-клієнт

-   Код, який працює з мережею, краще ізолювати в окремий клас-сервіс
-   Компоненти не повинні знати, звідки саме беруться дані
-   Такий підхід спростить тестування та підтримку коду, що працює з API

### Логіка індикатора завантаження

-   Додати поле loading до Redux state
-   Оновлювати це поле в reducer, коли дані стануть доступними
-   Передати значення loading в компонент
-   Залежно від стану loading, рендерити індикатор завантаження або вміст компонента (вже з даними)

### Обробка помилок

-   Помилка отриманих даних, потрібно зберегти в store, потім компонент зможе її відобразити

### Redux Thunk

Пакет redux-thunk — це middleware. З його допомогою ми розширюємо функціональність Redux, отримуючи можливість робити dispatch (надсилати) не тільки об'єкти, що описують дії, а й функції. Такі функції приймають dispatch і getState, у них ми можемо розмістити код із побічними ефектами

#### Thunk

Функція, яка робить якусь асинхронну задачу та вміє диспатчити action

### Використання `then` після `dispatch`

```jsx
/**
 * Поганий варіант.
 *
 * Треба зробити dispatch нашої Thunk і забути, а ми
 * очікуємо поки promise вирішиться.
 */
const onSubmit = (formData) => {
    saveProfile(formData).then(() => setEditMode(false));
};

/**
 * Гарний варіант.
 *
 * Додамо до нашого стану поле profileUpdateStatus,
 * з можливими значеннями 'none', 'success' або 'error'.
 */
export const saveProfile = (profile) => async (dispatch, getState) => {
    const userId = getState().auth.userId;
    const response = await profileAPI.saveProfile(profile);

    if (response.data.resultCode === 0) {
        dispatch(getUserProfile(userId));
        dispatch(setProfileUpdateStatus("success"));
    } else {
        dispatch(
            stopSubmit("edit-profile", { _error: response.data.messages[0] })
        );
        dispatch(setProfileUpdateStatus("error"));

        return Promise.reject(response.data.messages[0]);
    }
};

const onSubmit = (formData) => saveProfile(formData);

if (profileUpdateStatus === "success") setEditMode(false);
```

### Реалізація capture

```jsx
/**
 * CAPTURE
 *
 * 1. Робимо dispatch login-thunk.
 *
 * 2. Відбувається запит API, який при успішному запиті
 * поверне код 0 або 10.
 *
 * 3. Якщо статус код буде 10 — треба ввести capture.
 *
 * 4. Робимо dispatch getCaptchaUrl-thunk, яка додасть
 * у стан url картинки з capture.
 *
 * 5. У UI вводимо код з картинки.
 *
 * Виконуємо крок 1, якщо все добре статус код буде 0.
 *
 * 6. Робимо dispatch getAuthUserData-thunk, яка зробить
 * запит на API, щоб отримати дані о користувачі, якщо все ок,
 * робимо dispatch setAuthUserData(id, email, login, true)
 *
 */

/**
 * API.
 */
const login = (email, password, rememberMe = false, captcha = null) => {
    return instance.post(`auth/login`, {
        email,
        password,
        rememberMe,
        captcha,
    });
};

const getCaptchaUrl = () => {
    return instance.get(`security/get-captcha-url`);
};

/**
 * Redux.
 */
const GET_CAPTCHA_URL_SUCCESS = "samurai-network/auth/GET_CAPTCHA_URL_SUCCESS";

const initialState = {
    captchaUrl: null,
};

const authReducer = (state = initialState, action) => {
    switch (action.type) {
        case GET_CAPTCHA_URL_SUCCESS:
            return {
                ...state,
                ...action.payload,
            };
        default:
            return state;
    }
};

export const getCaptchaUrlSuccess = (captchaUrl) => ({
    type: GET_CAPTCHA_URL_SUCCESS,
    payload: { captchaUrl },
});

/** getCaptchaUrl-thunk */
export const getCaptchaUrl = () => async (dispatch) => {
    const response = await securityAPI.getCaptchaUrl();
    const captchaUrl = response.data.url;

    dispatch(getCaptchaUrlSuccess(captchaUrl));
};

/** getAuthUserData-thunk */
export const getAuthUserData = () => async (dispatch) => {
    const meData = await authAPI.me();

    if (meData.resultCode === ResultCodesEnum.Success) {
        const { id, login, email } = meData.data;
        dispatch(actions.setAuthUserData(id, email, login, true));
    }
};

/**
 * login-thunk
 */
export const login = (data) => async (dispatch) => {
    const response = await authAPI.login(...data);

    if (response.data.resultCode === 0) {
        dispatch(getAuthUserData());
        return;
    }

    if (response.data.resultCode === 10) {
        dispatch(getCaptchaUrl());
        return;
    }

    const message = response.data.messages.length
        ? response.data.messages[0]
        : "Some error";

    dispatch(stopSubmit("login", { _error: message }));
};

/**
 * JSX.
 */
function Login({ login }) {
    const captchaUrl = useSelector();
    const dispatch = useDispatch();

    const handleSubmit = () => {
        dispatch(
            login({
                email: formData.email,
                password: formData.password,
                rememberMe: formData.rememberMe,
                captcha: formData.captcha,
            })
        );
    };

    return <div>{captchaUrl && <img src={captchaUrl} />}</div>;
}
```

### React

**React** — opensource библиотека созданная Facebook, для того чтобы упростить создание
UI-компонентов и соответственно UI-приложений. Использует язык JSX. Использует
reconciliation алгоритм чтобы эффективно обновлять UI. Для того чтобы написать
полноценное приложение, нужно использовать дополнительные библиотеки.

**JSX** — создаёт вызов React.creatElement, в свою очередь creatElement создаёт маленький объект. Если мы создадим обычной тэг h1, это будет огромный объект с кучей свойств. React же использует легковесные объекты, эта техника называется VirtualDOM. В JSX можно вставлять массивы элементов (не только по-одному).

**ReactDOM.render** — превращает react-элементы, в html-элементы и рендерит их на странице.

4. Пользовательские интерфейсы состоят из компонентов — независимых блоков пользовательского
   интерфейса, которые могут иметь своё собственное поведение.

5. React компоненты — функции, которые возвращают React элемент, они начинаются с большой буквы,
   имя затем можно использовать в JSX как будто это HTML тег.

6. Props — свойства компонентов, объект который передаётся в каждый компонент. Мы можем передать
   любые свойства в любые React компоненты, для того чтобы получить свойства, со стороны компонентов,
   мы должны использовать объект PROPS, который передаётся внутрь каждой функции.

Массив можно передать как свойство. Так же можно передавать ВСЕ свойства объекта в компонент
используя Object Spread оператор (не перечисляя каждое) <TodoListItem {...item} /> .

7. Коллекции и ключи:

-   каждому элементу в массиве нужно уникальное свойство key;
-   React использует key чтобы эффективно сравнивать элементы при обновлении;
-   не стоит делать ключи из индексов массива.

8. Компоненты-классы:

-   используются, когда нужно хранить состояние;
-   классы наследуют React.Component;
-   метод render() возвращает элемент (как в функциональном компоненте);
-   props доступны через this.props.

9. Обработка событий:

-   добавить свойство onClick (onBlur, onMouseOver и тд.) к элементу;
-   передать функцию;
-   убедиться, что this сохранит правильное значение внутри функции.

10. State — состояние компонента, инициализируется в конструкторе или в теле класса. После инициализации
    state нельзя изменять (только читать). Чтобы обновить state, нужно использоваться setState().
    SetState() не должен изменять текущий state !!, в него нужно передавать только ИЗМЕНЕНИЯ в STATE.

11. Если новое состояние никак не зависит от предыдущего состояния можно использовать setState()
    и передавать внутрь объект, если же состояние зависит от предыдущего (нужно изменить значение true на false
    или нужно увеличить счётчик), тогда нужно внутрь setState() передать функцию аргумент которой и будет
    наш текущий state: setState((state) => {}).

12. Собственная система событий:

-   любой компонент может генерировать собственные события (onDone, onAdded и тд.);
-   достаточно передать callback функцию, как property, а затем вызвать её из компонента,
    когда наступило событие;
-   через события, данные поднимаются "вверх" по иерархии компонентов.

---------- ! React ----------

---------- Работа с сервером ----------

1. Данные в React приложении:

-   централизовать управление данными — хорошая практики;
-   если данные нужно использовать в нескольких компонентах — их нужно хранить в родительском компоненте;
-   чтобы "поднять" данные вверх по иерархии компонентов, используют события.

2. Для того чтобы сделать элемент контролируемым, нам нужно сделать так, чтобы значение элемента
   устанавливалось из состояния компонента. onChange() обновляет state, а state обновляет value элемента.

3. Чтобы получить данные сервера, нужно выполнить два вызова (каждый из них вернет Promise):

-   res = await fetch(url);
-   body = await fetch res.json().

4. Обработка ошибок в Fetch:

-   Fetch отклоняет (reject) Promise, если произошла ошибка сети или если мы выкинули ошибку;
-   Чтобы проверить код результата, можно использовать result.status;
-   result.ok содержит true, если result.status содержит один из статусов 200-299.

5. API-клиент:

-   код, который работает с сетью лучше изолировать в отдельный класс-сервис;
-   компоненты не должны знать откуда именно берутся данные;
-   такой подход упростит тестирование и поддержку кода работающего с API.

6. Трансформация данных в API:

-   изолируйте код, который обрабатывает данные;
-   отделяйте модель данных API от модели данных проложения.

7. Хорошее приложение не отображает элементы для которых нет данных.

8. Логика индикатора загрузки:

-   "состояние" загрузки можно хранить в state;
-   с зависимости от этого состояния, рендерим индикатор загрузки или содержимое компонента (уже с данными);
-   старайтесь разделять логику и рендеринг;
-   React.Fragment позволяет группировать элементы не создавая лишних DOM-объектов.

9. Обработка ошибок:

-   в state добавим поле, где будет хранить флаг: нужно ли отобразить ошибку;
-   в зависимости от этого флага, отображаем ошибку или нормальное содержимое компонента.

10. Итоги:

-   React ничего не знает о работе с сервером — это задачу других библиотек;
-   сетевой код следует изолировать от кода компонентов;
-   если необходимо, трансформируйте данные до того, как их получит компонент;
-   обрабатывайте состояние "загрузка" и "ошибка";
    !- разделяйте ответственность компонентов: логику и рендеринг.

---------- ! Работа с сервером ----------

---------- Жизненный цикл компонента ----------

1. Жизненный цикл:

-   компонентам нужно выполнять код в определенные моменты свой жизни;
-   к примеру, перед тем, как компонент будет удален, необходимо очистить ресурсы;
-   в React для этого есть механизм — методы жизненного цикла (lifecycle hooks).

2. componentDidMount() — компонент "подключен" (DOM элементы уже на странице),
   используется для инициализации (получение данных, работа с DOM и тд.).

В ООП считается плохой практикой, когда constructor() имеет side-эффекты (например начинает
делать запросы к серверу), потому что когда у объекта такой конструктор его сложнее тестировать
и с ним сложнее работать.

До того как React вызывает componentDidMount(), компонент считается unmounted (находится
в подвешенном состоянии, объект уже создан, но он ещё не до конца проинициализирован, в дереве
компонентов приложения, и до того как компонент станет mounted, то есть будет вызван
componentDidMount, вызывать setState нельзя, такой вызов к setState не будет иметь
никакого эффекта). Поэтому инициализацию компонентов которые зависят от внешних источников
данных лучше проводить в componentDidMount().

3. componentDidUpdate(prevProps, prevState) — вызывается после того, как компонент обновился.
   Компонент обновляется после того, как получает новые свойства или state. Так как этот метод
   вызывается после render(), в нём можно запрашивать новые данные для обновленных свойств.

Важно: если в этом методе может измениться state — обязательно проверять, какое свойство изменилось,
иначе компонент уйдёт в "вечный цикл" обновления.

4. componentWillUnmount() — компонент будет удален, но в момент вызова DOM все ещё находится
   на странице. Используется для очистки ресурсов (таймеры, интервалы, запросы к серверу).

5. componentDidCatch(error, info) — отлавливает ошибки, которые произошли в методах жизненного цикла
   ниже по иерархии. Чтобы определить границы ошибок, нужны компоненты, которые будут разделять независимые
   блоки проложения. Принимает два аргумента — error и info с дополнительной информацией об источнике ошибок.

Важно: не обрабатывает ошибки в event listener и в асинхронном коде (запросы к серверу и тп.).

6. Mount:
   constructor() => render() => componentDidMount()
   Update:
   New Props
   => render() => componentDidUpdate()
   setState
   Unmount:
   componentWillUnmount()
   Error:
   componentDidCatch()

---------- ! Жизненный цикл компонента ----------

---------- Паттерны React ----------

1. Использование функций:

-   функции, которые мы передаем компоненту могут быть не только обработчиками событий;
-   функция, к примеру, может инкапсулировать получение данных (тогда компонент становится независимым
    от источника данных).

2. Render-функция — паттерн React когда вы передаёте в React-компонент функцию, которая рендерит части
   компонента (или всего компонент). Такая функция обычно возвращает строку или React-компонент.
   <Card renderBody={() => <p>Hello</p>} />

3. Свойства-элементы.
   В качестве значений свойства можно передавать React-элемент, так можно создавать элементы "контейнеры"
   или элементы, которые умеют выбирать, что рендерить в зависимости от условия (загрузка, ошибка и т.п.).
   <Card title={<p>Hello</p>} />

4. Рендер-пропсы:

-   компоненту можно передавать одно из свойств, поместив его в тело элемента: <Card>Hello</Card>
    Этом свойство доступно через props.children. Поддерживает любые типы данных (элементы, функции,
    объект и др.)
-   компонент может решать, как именно использовать children;
-   функция React.Children.map() упрощает обработку props.children;
-   child-элементы можно заменять, оборачивать в другие компоненты или скрывать (если вернуть null).

5. Клонирование элементов.
   React-элементы нельзя изменять (они считаются immutable), но можно создавать модифицированные копии
   при помощи React.cloneElement(), к примеру, элементам можно добавлять новые свойства.

6. Компонент высшего порядка (Higher-Order Component, HOC) — функция, которая создает компоненты и
   оборачивает существующие.

7. Рефакторинг компонентов:

-   обратная сторона "гибкости" компонентов это громоздкая конфигурация;
-   код будет более читабельным, если вынести детали конфигурации в отдельные компоненты, для этого можно
    использовать HOC или просто написать компонент-обертку вручную.

8. Композиция HOC:

-   композиция применение одной функции к результату другой: f(g(x));
-   композиция высшего порядка это обычные функции, которые возвращают компоненты;
-   мы можем применять несколько "эффектов" HOC.

9. Контекст:

-   контекст нужен для того, чтобы решить проблему "глобальных данных";
-   вместо того, чтобы передавать props через все слои приложения, данные можно передавать через контекст;
-   с помощью контекста мы сможем сделать так, чтобы компоненты не создавали объекты сервиса, а получили его;
-   может быть полезен при реализации функционала поддержки языков, тем визуального оформления и тд.

10. HOC + Context: обязанность получать данные из контекста можно вынести в компонент высшего порядка.

11. Трансформация свойств:

-   HOC может преобразовать свойства перед тем, как передавать их компоненту (например, изменять их имена
    и выбирать какие именно свойства нужно передать);
-   При помощи дополнительной функции (mapMethodsToProps) можно определять это поведение для каждого компонента.

12. Обновление контекста:

-   значение в контексте можно обновлять, как любое другое свойство компонента;
-   компоненты должны поддерживать изменение нужных свойств;
-   componentDidUpdate() — функция в которой можно проверить, какие свойства изменились.

13. Частично примененный функции — функции которые принимают часть аргументов и возвращают новые
    функции с меньшим количеством аргументов: const add = (a) => (b) => a + b

14. propTypes:

-   позволяет проверить значения свойств (props), которые получает компонент;
-   проверка срабатывает после defaultProps;
-   функция-валидатор возвращает null или объект Error.

15. Библиотека prop-types — набор стандартных функций-валидаторов. Есть и другие библиотеки с
    дополнительными валидаторами, например airbnb-prop-types.

---------- ! Паттерны React ----------

---------- React Hooks ----------

1. Хуки:

-   хук, это обычная функция, имя которой называется с use;
-   хуки дают возможность компонентам-функциям работать со состоянием, жизненным циклом и контекстом.

2. Правила и ограничения хуков:

-   хуки нельзя использовать в циклах и условиях, нельзя изменять порядок хуков, хуки должны вызываться
    одинаковое и в одинаковой последовательности
    (потому что изменится порядок вызова хуков, и хуки перестанут нормально работать);
-   хуки можно использовать только в React компонентах и других хуках
    (потому что React связывает то состояние которое мы сохраняем в хуках с конкретным экземпляром
    конкретного компонента, если мы пытаемся вызвать хук из обычной функции не являющейся React-компонентом,
    то React не будет знать каким образом сохранить эти данные, а затем корректно вернуть их обратно);
-   хуки нельзя использовать в классах;
-   не все возможности React можно реализовать при помощи хуков (например, componentDidCatch()
    работает только в классах).

3. useState:

-   добавляет state в функциональные компоненты;
-   возвращает массив: текущее значение и функция для установки нового значения;
-   всегда обновляет объект полностью, а не отдельные поля как setState().

4. useContext:

-   получает значение из заданного контекста;
-   код создания контекста и установки значения остается без изменений;
-   в useContext() передается именно объект-контекст (а не Consumer).

5. useEffect:

-   первым параметром принимает callback, вторым массив зависимостей при изменении которых будет
    вызываться данный хук;
-   запускает функцию каждый раз, когда определенный набор данных изменился;
-   если данные зависят от параметра (например, ID ресурса) — нужно указывать его в массиве;
-   если хотим вызвать useEffect один раз, нужно передать пустой массив;
-   если в callback, передать ещё одну функцию callback, она будет вызываться для очистки предыдущего
    эффекта (похоже на componentWillUnmount);
-   promise нельзя отменить, но можно проигнорировать результат.

7. useCallback:

-   сохраняет функцию между вызовами, если данные в массиве зависимостей не изменились;
-   используется довольно часто когда наши хуки зависят от функции, пересоздавать функцию каждый раз,
    как правило, не имеет смысла, более того, это может привести к неправильной работе приложения. Нужно
    использовать хук useCallback(), который запоминает значение переданной в него функции и обновляет её
    только тогда, когда данные в массиве изменились с прошлого вызова. Этот паттерн когда запоминаем значение
    переменной или функции называется Memo;
-   const f = useCallback(() => loadData(id), [id]);
    f — функция из первого аргумента.

8. useMemo:

-   сохраняет значение между вызовами, если данные в массиве зависимостей не изменились;
-   работает практически так же как и хук useCallback(), только useCallback() кэширует само значение,
    саму функцию, а useMemo кэширует результат работы этой функции.
-   const f = useMemo(() => getValue(id), [id]);
    f — результат функция из первого аргумента.

9. useReducer:

-   обычно предпочтительнее useState, когда у вас сложная логика состояния, которая
    включает в себя несколько значений, или когда следующее состояние зависит от предыдущего;
-   позволяет вынести логику в отдельный файл.

---------- ! React Hooks ----------

---------- React Router ----------

1. Routing — переключение между "виртуальными" страницами UI приложения. Routing нужен,
   чтобы упростить структуру приложения и организовать навигацию. В Single Page Application
   страница, на самом деле, одна и она не перезагружается.

2. React Router это не часть React. Есть и другие библиотеки для routing (к примеру, UI-React).

3. Link:

-   чтобы переключат страницы, используйте компонент Link из react-router;
-   Link работает почти как тег <a>, но он не перезагружает страницу (и при этом обновляет URL
    в адресной строке).

4. Как работает Route:

-   в Route можно передать render-функцию;
-   Route работает как фильтр — сравнивая path с текущим адресом он решает, рендерить содержимое или нет;
-   Параметр exact говорит, что нужно использовать точное совпадение, вместо "path является часть адреса".

5. Динамические пути:

-   в Route можно передавать параметры:
-   :id может быть любой строкой, которая идет после /people/;
-   если не установить exact, пусть endPoint/people будет срабатывать всегда, когда срабатывает /people/:id.

6. withRouter — компонент высшего порядка, которые передает компоненту объекты react-router.

7. Относительные пути:

-   в react-router можно использовать относительные пути;
-   закрывающий слэш — очень важен;

8. Опциональные параметры:

-   в path параметры могут быть опциональными;
-   приложение должно позволять перезагружать страницы, или передавать URL другим пользователям;
-   адрес должен содержать ID открытого элемента (тогда открыв URL пользователь попадает на тот-же экран).

9. Авторизация:

-   можно использовать компонент Redirect, чтобы переслать пользователя на логин страницу;
-   система авторизации, которую мы рассмотрели, не обеспечивает безопасность в приложении
    (проверка прав должна проводиться на сервере).

10. Switch:

-   компонент Switch оборачивает другие компоненты (Route и Redirect);
-   Switch рендерит только первый элемент, который соответствует адресу;
-   Route без свойства path срабатывает всегда.

---------- ! React Router ----------

---------- Redux ----------

1. Введение в Redux:

-   Redux решает проблему управления состоянием в приложении;
-   Redux предлагает хранить state в одном "глобальном" объекте;
-   функция Reducer обновляет глобальный state в ответ на Action (действие);
-   Объект Store координирует обновления.

2. Библиотеки:

-   redux — сам Redux;
-   react-redux — библиотека, которая упрощает интеграцию между React и Redux.

3. Reducer:

-   Reducer это обычная функция: (state, action) => newState;
-   если state — undefined, тогда нужно вернуть первоначальный (initial) state;
-   если тип action неизвестен — нужно вернуть state без изменений.

4. Redux Store:

-   Store координирует работу с данными в Redux приложении.

5. Чистые функции:

-   возвращаемое значение зависит только от аргументов (для одинаковых аргументов чистая функция
    всегда будет возвращать одинаковые результаты);
-   у функции нет побочных эффектов (обновления глобальной переменной, обновление DOM-дерева,
    запись значения в кэш, запись в БД, модифицирование аргументов, вызов таймаута, вызов сервера и тд.);
-   reducer это чистая функция (зависит исключительно от state и action которые он получил).

6. UI для Redux:

-   в качестве UI может использоваться любая библиотека или фреймворк;
-   store.dispatch(action) используется для обновления состояния;
-   store.subscribe(listener) используется для обновления UI.

7. Действия с параметрами:

-   кроме типа, любое действие (action) может содержать дополнительную информацию;
-   часто дополнительные параметры передаются в поле payload.

8. Action Creator — функция, которая создает объект action.

9. Структура проекта:

-   есть несколько подходов к структуре Redux проекта;
-   один из подходов — вынести reducer-функции и action creator функции в отдельные файлы или папки.

10. bindActionCreators:

-   bindActionCreators() — связывает функцию action creator с функцией dispatch();
-   созданные таким способом функции делают сразу два действия — создание действия (action) и отправка
    action в dispatch;
-   const {add, remove} = bindActionCreators(actions).

11. React и Redux:

-   React должен "знать" когда нужно обновлять компоненты (store.subscribe должен сказать об
    обновлении state);
-   React компоненты должны быть как можно меньше связаны с Redux.

12. react-redux и функция connect:

-   react-redux упрощает интеграцию react + redux;
-   Provider делает store доступным всему дереву компонентов (через контекст);
-   connect() — компонент высшего порядка, которые передает значения из store в компонент.

13. mapDispatchToProps:

-   mapDispatchToProps() — второй аргумент для функции connect();
-   созданные функции будут переданы в компонент, таким способом компонент может обновить
    состояние в store.

14. mapDispatchToProps как объект:

-   Action Creator необязательно должен быть чистой функцией;
-   если второй аргумент connect() это объект, то результат будет таким же как для кода:
    const mapDispatchToProps = (dispatch) => bindActionCreators(actions, dispatch);
    connect(mapStateToProps, mapDispatchToProps)(Counter).

---------- ! Redux ----------

---------- Разработка Redux приложения ----------

1. Вспомогательные компоненты:

-   большинству приложений необходимы вспомогательные компоненты (ErrorBoundary, Context, HOC);
-   эти и другие вспомогательные компоненты лучше создавать сразу (до начала работы над основным
    функционалом приложения).

2. Redux компоненты:

-   для того чтобы создать Redux приложение, нужно определить функцию-reducer;
-   функции action-creators необязательно использовать, но на практики они присутствуют всегда;
-   логику создания store удобно вынести в отдельный файл.

3. Dispatch:

-   чтобы получить данные из service и передать их в Redux Store мы использовали два HOC:
    withBookstoreService() — получает сервис из контекста и передает в компонент,
    connect() — оборачивает функцию dispatch из Redux Store;
-   mapDispatchToProps — может быть функцией или объектом, если это объект, он передается в
    bindActionCreators().

4. Принцип работы компонента BookList с Redux:

-   в нашем приложении начинаем с пустого массива в Redux Store;
-   как только наш компонент загружается, функция connect() оборачивает наш компонент BookList в
    HOC, который подключается к Redux Store, мы конфигурируем то, как происходит это подключение
    с помощью при помощи функций mapStateToProps и mapDispatchToProps;
-   mapStateToProps — описывает то, какие именно данные наш компонент хочет получить из Redux Store;
-   mapDispatchToProps — описывает то, какие именно действия хочет выполнить наш компонент (какие
    actions он будет передавать в store);
-   когда наш компонент появляется на экране мы:
    -   получаем из контекста bookstoreService при помощи HOC withBookstoreService();
    -   получаем данные используя bookstoreService();
    -   вызываем функцию booksLoaded().
-   booksLoaded — это уже не обычный action creator, он не просто создаёт действие, а автоматически
    передаёт этот самый action в Redux Store;
-   мы передаём те данные которые получили от bookstoreService в Redux Store;
-   Redux Store вызывает наш reducer;
-   reducer получает action 'BOOKS_LOADED' и обновляет список книг в state;
-   обновленный список книг снова возвращается к нашему компоненту BookList;
-   через mapStateToProps(), наш компонент получает обновленный список книг и в функции render
    показывает этот список на экране.

5. Асинхронные данные.
   Реализовать загрузку данных в Redux можно так-же, как и в обычном React приложении, для этого нужно:

-   добавить поле loading в Redux state;
-   обновлять это поле в reducer, когда данные становятся доступны;
-   передать значение loading в компонент, используя mapStateToProps.

6. setState и reducer:

-   в setState() можно передавать только ту часть state, которую нужно обновить;
-   reducer должен вернуть полный объект: return {...state, updatedProp: newValue};

7. Обработка ошибок:

-   ошибку поученных данных, нужно сохранить в store, затем компонент сможет её отобразить;
-   чтобы сохранить ошибку, нужно создать отдельное действие (BOOK_FETCH_ERROR);
-   саму ошибку можно передать вместе с действием и сохранить в store.

8. Аргумент ownProps — свойство нашего компонента которое он получил сверху от других компонентов,
   в нашем случае от withBookstoreService(). Мы вынесли логику обработку данных из componentDidMount в
   отдельную функции которую мы создали внутри mapDispatchToProps(), раньше mapDispatchToProps был объект,
   мы сделали из него функцию, что позволило получить доступ к dispatch и ownProps.

9. Action fetchBooks() возвращает функцию, потому что мы не хотим чтобы наш компонент, который будет
   вызывать fetchBooks напрямую зависел от этих параметров, наш компонент должен просто вызвать fetchBooks()
   без аргументов и запустить процесс получения книг.

10. Naming Convention:

-   FETCH_BOOKS_REQUEST — запрос отправлен;
-   FETCH_BOOKS_SUCCESS — получен результат (в payload передаются полученные данные);
-   FETCH_BOOKS_FAILURE — произошла ошибка (в payload передается объект Error).

11. Компоненты-контейнеры:

-   презентационные компоненты — отвечают только за рендеринг;
-   компоненты-контейнеры — работают с Redux, реализуют loading, error и другую логику (такие компоненты
    иногда выносят в отдельные файлы "PersonContainer" или папки "/containers").

12. Новый компонент:

-   начните с создания нового презентационного компонента, он не должен "знать" о Redux;
-   обновите state, добавьте туда новые поля;
-   для начала заполните state тестовыми данными;
-   реализуйте функции для connect() и подключите компонент к Redux.

13. Добавление в массив:

-   в Redux-приложения, так же как и в React нельзя модифицировать state;
-   добавлять элемент в массив нужно так: return {items: [...state.items, item]}.

14. Организация кода reducer:

-   как только reducer становится сложным — сразу упрощайте его;
-   работайте со структурой глобального state: объединяйте свойства в объекты;
-   выносите логику обновления объектов из глобального state в отдельные функции.

15. Store Enhancer управляет процессов создания store. Возвращает новую реализацию createStore.

16. Middleware — функции, которые последовательно вызываются при обработке действий:
    const logAll = (store) => (next) => (action) => {}, используются намного чаще, чем Store Enhancer.

17. Thunk middleware — позволяет передавать в store функции как действия. Такие функции принимают
    dispatch() и getState().

---------- ! Разработка Redux приложения ----------

---------- Сборка React приложений (Babel) ----------

1. Чтобы создать новый проект: npm init.

2. Babel установка:

-   установка Babel: npm i -DE @babel/core @babel/cli;
-   без дополнительных модулей Babel не трансформирует код, поэтому файлы останутся без изменений.

3. Babel плагины:

-   каждый плагин Babel отвечает за отдельную синтаксическую конструкцию языка;
-   плагины устанавливаются как NPM пакеты;
-   запуск Babel с плагинами: npx babel src --out-dir build --plugins plugin1,plugin2,plugin3.

4. Файлы конфигурации Babel:

-   конфигурация Babel обычно хранится в отдельных файлах: .babelrc или babel.config.js;
-   синтаксис .babelrc обычный JSON.

5. Babel presets:

-   preset — заранее сконфигурированный список плагинов;
-   как и плагины устанавливается через NPM;
-   .babelrc может одновременно содержать блоки presets и plugins.

6. Поддержка браузеров:

-   babel-presets-env позволяет указывать список браузеров на которых должен запускаться код;
-   следует избегать "лишних" трансформаций (не преображать то, что и так поддерживается).

7. Динамический выбор браузеров:

-   babel-presets-env позволяет использовать выражения, чтобы описывать список браузеров;
-   browserslist отвечает за парсинг выражений;
-   добавив к конфигурации babel-presets-env флаг debug: true, можно получить детальную информацию
    о браузерах и трансформациях.

8. Файлы конфигурации browserslist:

-   список браузеров можно хранить в следующих файлах:
    -   .babelrc — в настройках preset-env;
    -   package.json — в блоке browserslist;
    -   в файле .browserslist — в каждой строке по отдельному выражению.

9. Polyfills:

-   polyfills — код, который добавляет глобальную функцию (если её ещё нет в браузере);
-   core-js — библиотека polyfills.

10. Работа c JSX:

-   @babel/preset-react содержит трансформации, необходимые для работы с JSX кодом;
-   конфигурация .babelrc.

11. Организация зависимостей:

-   dependencies — модули, которые нужны во время работы приложения;
-   devDependencies — модули для разработки и сборки приложения.

---------- ! Сборка React приложений (Babel) ----------

---------- Сборка React приложений (WebPack) ----------

1. Что такое WebPack:

-   задача WebPack — сборка и оптимизация JavaScript приложений;
-   WebPack анализирует модули и их зависимости и создает bundle — один или несколько
    файлов, готовых для production.

2. Установка WebPack:

-   установка WebPack: npm i -DE webpack webpack-cli
-   запуск WebPack: npx webpack --mode development;
-   mode development — для разработки (работает быстрее, не минифицирует файлы);
-   mode production — создаёт оптимизированный build.

3. Файл конфигурации WebPack:

-   webpack.config.js — файл конфигурации;
-   файл исполняется в среде Node.js.

4. WebPack Loader:

-   WebPack обрабатывает файлы при помощи loaders (NPM модули, которые каким-то образом
    обрабатывают файл);
-   большинство loaders можно конфигурировать используя блок options;
-   один loader можно использовать для разных расширений;
-   разные типы файлов (например шрифты и изображения) лучше размещать в разных
    блоках use, даже если они используют один loader.

5. React и Babel Loader:

-   большинство loaders преобразуют файлы (транспилируют, анализируют, сжимают и т.п.);
-   babel-loader запускает babel для обработки файлов (конфигурация — в .babelrc);
-   можно указывать исключения для правил.

6. Композиция Loaders:

-   в WebPack один файл может образовываться последовательно несколькими Loaders;
-   порядок имеет значение, первый файл обрабатывает последний loader из массива.

7. CSS препроцессоры:

-   препроцессоры добавляются в цепочку loaders (они первыми обрабатывают файл);
-   обращайте внимание на поддержку "чистых" форматов (к примеру, обычный CSS).

8. Упрощения синтаксиса:

-   loader вместо блока use (если loader один и нет дополнительных конфигураций):
    loader: loader1;
-   если нет дополнительных конфигураций, но loaders несколько:
    use: [loader1, loader2].

9. Плагины:

-   loaders — используются для работы с одним модулем;
-   плагины — для работы со всем проектом.

10. Использование шаблонов:

-   HtmlWebPackPlugin — может интерпретировать HTML-файл как шаблон.

11. MiniCSS Extract Plugin:

-   mini-css-extract-plugin — сохраняет все фрагменты CSS кода в отдельный файл;
-   конфигурацияЖ добавить plugin и loader;
-   блок rules, loaders для CSS:
    use: [MiniCssExtractPlugin.loader, 'css-loader'].

12. WebPack Dev Server:

-   запускает веб-сервер, отдает файлы собранного приложения (папка "dist");
-   производит сборку в памяти, не сохраняет файлы в файловой системе.

13. Конфигурация для production:

-   production конфигурация существенно отличается от development конфигурации;
-   параметры из командной строки: webpack --env mode=production.

---------- ! Сборка React приложений (WebPack) ----------
